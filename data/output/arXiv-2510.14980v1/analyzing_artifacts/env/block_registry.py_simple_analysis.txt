### **Logic Analysis: env/block_registry.py — BlockRegistry Class**

---

#### **1. Purpose and Role in System**
The `BlockRegistry` class serves as the **centralized, immutable source of truth** for all 27 mechanical blocks defined in *BesiegeField*. It provides **metadata lookup** for block types, enabling consistent, error-free handling across all system components:  
- `ConstructionTree` validates block types and attachment rules.  
- `BesiegeFieldSimulator` applies correct physics properties (mass, friction) during simulation.  
- `XMLConverter` maps XML block names to internal representations.  
- `ActiveEnvQuerier` and `RewardCalculator` may reference block types to determine which blocks to query (e.g., “Spring” for length, “Boulder” for trajectory).  

This design avoids hardcoding block properties in multiple modules, ensuring **maintainability**, **consistency**, and **extensibility** (e.g., future addition of new blocks via config).

---

#### **2. Core Data Structure: Block Metadata Schema**
Each block must be represented with the following **fixed metadata fields**, derived exclusively from the paper’s “Details on the BesiegeField Environment::Blocks”:

| Field | Type | Description | Source |
|-------|------|-------------|--------|
| `type` | `str` | Human-readable block name (e.g., `"Powered Wheel"`) | Directly from paper list |
| `attachable_faces` | `int` | Number of faces available for attachment (0–6) | Inferred: cuboid blocks have 6 faces; Spring is special (0) |
| `is_special` | `bool` | `True` if block violates standard attachment rules (only `Spring`) | Explicitly stated: “Spring... can have two parents... does not occupy attachable faces” |
| `mass` | `float` | Mass in kg (for physics simulation) | Inferred: “Heavy cubic block” → `Ballast` = 50kg; “Slender, fragile” → `Wooden Rod` = 1kg; others = 5kg default |
| `friction` | `float` | Coefficient of friction (0.0–1.0) | Inferred: `Grip Pad` = 1.0 (highest), `Elastic Pad` = 0.3 (high elasticity, low friction), others = 0.5 default |
| `is_powered` | `bool` | Whether block receives control commands (activates at t=2s) | From paper: “Powered cogs”, “Powered Wheel”, “Rotating Block”, etc. |

> **Note**: The paper does not specify exact physical values. We **infer them logically** from block semantics and ensure they are **consistent with simulation requirements** (e.g., `Ballast` must be heavy enough to stabilize catapults; `Wooden Rod` must break under stress). These values are **not configurable via YAML** — they are **hardcoded based on design intent**, as the paper treats them as fixed properties of the domain.

---

#### **3. Block List Mapping: 27 Blocks with Metadata**
We map all 27 blocks from the paper into a static dictionary (`_BLOCK_METADATA`) initialized in `__init__`. Each entry is keyed by the exact string name as listed. Special handling for `Spring`:

```python
_BLOCK_METADATA = {
    "Starting Block": {
        "attachable_faces": 0,  # Root has no attachable faces; it is the origin
        "is_special": False,
        "mass": 10.0,           # Fixed base; moderate mass for stability
        "friction": 0.5,
        "is_powered": False
    },
    "Small Wooden Block": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 5.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Wooden Block": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 10.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Wooden Rod": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 1.0,            # Fragile — low mass for breakage
        "friction": 0.5,
        "is_powered": False
    },
    "Log": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 15.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Steering Hinge": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 8.0,
        "friction": 0.5,
        "is_powered": True      # Powered: controls rotation
    },
    "Steering Block": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 8.0,
        "friction": 0.5,
        "is_powered": True
    },
    "Powered Wheel": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 12.0,
        "friction": 0.8,        # High friction for traction
        "is_powered": True
    },
    "Unpowered Wheel": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 12.0,
        "friction": 0.8,
        "is_powered": False
    },
    "Large Powered Wheel": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 36.0,           # 3x radius → 27x volume? → 3x mass approx
        "friction": 0.8,
        "is_powered": True
    },
    "Large Unpowered Wheel": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 36.0,
        "friction": 0.8,
        "is_powered": False
    },
    "Small Wheel": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 6.0,
        "friction": 0.7,
        "is_powered": False
    },
    "Roller Wheel": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 4.0,
        "friction": 0.7,
        "is_powered": False
    },
    "Universal Joint": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 5.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Hinge": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 5.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Ball Joint": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 5.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Axle Connector": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 5.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Suspension": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 8.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Rotating Block": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 10.0,
        "friction": 0.5,
        "is_powered": True      # Generates torque
    },
    "Grabber": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 8.0,
        "friction": 0.5,
        "is_powered": True      # Can grab/release
    },
    "Boulder": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 50.0,           # Heavy projectile
        "friction": 0.6,
        "is_powered": False
    },
    "Grip Pad": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 5.0,
        "friction": 1.0,        # Highest friction
        "is_powered": False
    },
    "Elastic Pad": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 5.0,
        "friction": 0.3,        # High elasticity, low friction
        "is_powered": False
    },
    "Container": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 10.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Spring": {
        "attachable_faces": 0,  # Does not consume attachable faces — special rule
        "is_special": True,     # Can have two parents
        "mass": 2.0,            # Light, flexible
        "friction": 0.4,        # Low friction for smooth motion
        "is_powered": False
    },
    "Brace": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 8.0,
        "friction": 0.5,
        "is_powered": False
    },
    "Ballast": {
        "attachable_faces": 6,
        "is_special": False,
        "mass": 50.0,           # Heavy counterweight
        "friction": 0.5,
        "is_powered": False
    }
}
```

> **Critical Inference**:  
> - `Spring` has `attachable_faces=0` because it **does not consume** attachable faces on parents — a unique rule.  
> - All other blocks have 6 attachable faces (cuboid assumption).  
> - `is_special=True` **only for Spring** — no other block has multiple parents or non-standard attachment.  
> - `is_powered=True` only for blocks explicitly labeled “powered” in the paper:  
>   `Steering Hinge`, `Steering Block`, `Powered Wheel`, `Large Powered Wheel`, `Rotating Block`, `Grabber`.

---

#### **4. Interface Methods: `get_block_info`, `is_special_block`, `get_attachable_faces`**

##### **`__init__()`**
- **Action**: Initializes `_BLOCK_METADATA` as a frozen dictionary (no runtime modification).  
- **Validation**: On init, verify that all 27 block names are present and no duplicates.  
- **Performance**: Use `frozenset` of block names for O(1) lookup in validation.  
- **No external dependencies** — all data is static and hardcoded.

##### **`get_block_info(block_type: str) -> dict`**
- **Input**: Exact string name (e.g., `"Powered Wheel"`).  
- **Output**: Full metadata dict.  
- **Error Handling**: If `block_type` not in registry, raise `ValueError(f"Unknown block type: {block_type}")`.  
- **Usage**: Called by `ConstructionTree.validate()` to check if a block type is valid.  
- **Example**:  
  ```python
  info = registry.get_block_info("Spring")
  assert info["is_special"] == True
  assert info["attachable_faces"] == 0
  ```

##### **`is_special_block(block_type: str) -> bool`**
- **Wrapper** around `get_block_info(block_type)["is_special"]`.  
- **Purpose**: Used by `ConstructionTree` to enforce two-parent logic.  
- **Optimization**: Pre-compute a `special_blocks_set = {"Spring"}` for O(1) lookup.  
- **Usage**:  
  ```python
  if registry.is_special_block(child_type):
      # Allow parent_a and parent_b
  ```

##### **`get_attachable_faces(block_type: str) -> int`**
- **Wrapper** around `get_block_info(block_type)["attachable_faces"]`.  
- **Purpose**: Used by `BesiegeFieldSimulator.build_from_tree()` to determine:  
  - How many faces are available on a parent block for new attachments.  
  - Whether a newly placed block’s free end can auto-connect to an existing block.  
- **Critical Logic**:  
  - If a block has `attachable_faces = 0`, it **cannot** be a parent (e.g., `Spring` can be a child but not a parent).  
  - Only blocks with `attachable_faces > 0` can be parents.  
  - This enforces the **DAG constraint**: no cycles, root-only origin.

---

#### **5. Integration Points with Other Modules**

| Module | How It Uses BlockRegistry | Why It Matters |
|--------|---------------------------|----------------|
| `ConstructionTree.validate()` | Uses `get_block_info()` to validate `type` field; uses `is_special_block()` to validate `parent_a/parent_b` usage | Ensures JSON is semantically valid before simulation |
| `BesiegeFieldSimulator.build_from_tree()` | Uses `get_attachable_faces()` to track which faces on each parent are occupied; uses `is_special_block()` to handle Spring’s dual-parent rule | Prevents invalid attachments and auto-connect logic |
| `XMLConverter.from_xml_to_tree()` | Uses `get_block_info()` to validate block names in XML; maps XML names to standard names | Ensures legacy XML format is compatible with construction tree |
| `ActiveEnvQuerier.selective_query()` | Uses `is_special_block()` to know when to query `length` for Spring | Enables intelligent feedback (e.g., if Spring length is near zero → likely snapped) |
| `RewardCalculator` | Uses `is_powered` to determine if a block activates at t=2s | Critical for simulating functional behavior (e.g., powered wheels drive car) |

> ✅ **No module modifies `BlockRegistry` at runtime** — it is **read-only**. This ensures **determinism** in simulation and agent behavior.

---

#### **6. Edge Cases and Validation Rules**

| Case | Handling |
|------|----------|
| **Block name typo** (e.g., “Powerd Wheel”) | `get_block_info()` raises `ValueError` — caught by `ConstructionTree.validate()` and `DatasetCurator` during filtering |
| **Spring as parent** | `get_attachable_faces("Spring") == 0` → prevents it from being used as parent in construction tree → enforced in `build_from_tree()` |
| **Two-parent block not Spring** | `ConstructionTree.validate()` checks: if `parent_a` exists → `is_special_block(type)` must be `True`, else raise `InvalidStructureError` |
| **Missing metadata field** | `__init__()` asserts all 27 blocks have all 5 fields — fails fast on misconfiguration |
| **New block added** | Must be manually added to `_BLOCK_METADATA` — no dynamic loading (paper implies fixed set of 27) |

---

#### **7. Configuration and Extensibility**

- **No YAML configuration** for block metadata.  
  - **Reason**: The paper defines a **fixed, closed set of 27 blocks**. Adding new blocks would change the task definition.  
  - **Extensibility**: Future work (e.g., fluid simulation) would require a **new registry subclass** or **plugin system** — outside current scope.  
- **All values are hardcoded** based on logical inference from paper semantics.  
  - **Justification**: The paper does not provide physical parameters — we must **define them consistently** to enable reproducible simulation.  
  - **Traceability**: All inferred values are documented inline in code (as above).

---

#### **8. Dependencies and Isolation**

- **Dependencies**: `None` — as specified.  
- **No external libraries** used. Pure Python dictionary.  
- **No logging** — this is a low-level utility. Errors are raised as exceptions for higher modules to handle.  
- **Thread-safe**: Immutable dict → safe for multi-process simulation (8 workers).  

---

#### **9. Summary: Design Philosophy**

| Principle | Implementation |
|----------|----------------|
| **Single Source of Truth** | One dict, one class, no duplication |
| **Explicit over Implicit** | Every block’s properties are explicitly defined, not inferred at runtime |
| **Fail Fast** | Invalid block names or structures raise immediate errors |
| **Deterministic** | No randomness, no config drift — same metadata across all runs |
| **Minimalist** | Only what’s needed: type, faces, special, mass, friction, powered |
| **Reproducible** | Values are documented and justified from paper semantics |

---

#### **10. Next Steps for Implementation**

1. Define `_BLOCK_METADATA` as a private static dictionary in `BlockRegistry.__init__()`.  
2. Precompute `self._special_blocks = {"Spring"}` and `self._valid_block_names = frozenset(_BLOCK_METADATA.keys())`.  
3. Implement the three methods with strict input validation and error messages.  
4. Add unit tests:  
   - `test_get_block_info_valid()`  
   - `test_get_block_info_invalid()`  
   - `test_is_special_block()`  
   - `test_get_attachable_faces()`  
   - `test_all_27_blocks_present()`  
5. Ensure `BlockRegistry` is instantiated **once** and shared across all modules (via dependency injection or singleton pattern).

---

This `BlockRegistry` is the **foundational layer** upon which all machine construction, validation, and simulation depend. Its correctness ensures that every agent, simulation, and reward calculation operates on a **shared, unambiguous model of the mechanical world**.