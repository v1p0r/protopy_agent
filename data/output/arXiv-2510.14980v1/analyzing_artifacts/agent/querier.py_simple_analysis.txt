# Logic Analysis: `agent/querier.py` â€” `ActiveEnvQuerier` Class

---

## **1. Role and Purpose**

The `ActiveEnvQuerier` class is a **feedback orchestrator** within the iterative editing agent workflow. Its core responsibility is to **extract and synthesize actionable environmental feedback** from a simulated machine design, enabling the `Refiner` and `InspectorRefiner` to generate meaningful revisions. It does *not* perform simulation â€” it consumes simulation output and *selectively queries* state data to infer failure modes.

It bridges the gap between **low-level physics simulation logs** and **high-level human-interpretable critique signals**, making it critical for enabling LLMs to reason about *why* a machine failed.

---

## **2. Inputs and Dependencies**

### **Inputs**
- **`state_log: list[dict]`**:  
  Generated by `BesiegeFieldSimulator.get_state_log()`, this is a time-series list of per-block states at 0.2s intervals (total 25 steps for 5s simulation).  
  Each entry is a dictionary with keys:  
  ```python
  {
    "block_id": int,           # ID of block (matches ConstructionTree.id)
    "type": str,               # e.g., "Boulder", "Container", "Powered Wheel"
    "position": [x, y, z],     # 3D global position at this timestep
    "orientation": [qx, qy, qz, qw],  # quaternion (or Euler if converted)
    "velocity": [vx, vy, vz],  # linear velocity
    "angular_velocity": [wx, wy, wz], # angular velocity
    "integrity": float,        # 1.0 = intact, 0.0 = broken
    "length": float,           # only for Spring blocks; current length
    "is_powered": bool         # whether block is powered (e.g., Rotating Block)
  }
  ```

- **`design: ConstructionTree`**:  
  The machine structure that was simulated. Used to:
  - Map `block_id` â†’ block type (via `get_block_info()` from `BlockRegistry`)
  - Identify special blocks (e.g., Boulder, Container, Spring)
  - Determine attachment hierarchy (to find â€œlast attachedâ€ block)

- **`task: str`**:  
  Either `"car"` or `"catapult"`. Determines which feedback is minimal and how to interpret failure.

### **Dependencies**
- `simulation.py`:  
  Provides `state_log` via `SimulationEngine` or directly from `BesiegeFieldSimulator`.  
  *Note: The paper implies `BesiegeFieldSimulator` is the source, but `simulation.py` may be the wrapper that standardizes output. We assume `state_log` comes from `BesiegeFieldSimulator` and is passed through `simulation.py`.*

- `representation/construction_tree.py`:  
  Used to access the machineâ€™s **construction order** and **parent-child relationships**.  
  Required for:
  - Identifying the **root block** (for car task)
  - Identifying the **boulder block** (for catapult task)
  - Tracing **attachment ancestry** to find the last block added (for failure diagnosis)

- `env/block_registry.py`:  
  Used to:
  - Confirm block types (e.g., validate that block_id=5 is indeed a â€œBoulderâ€)
  - Determine if a block is a **Spring** (to access `length` field)
  - Determine if a block is **powered** (to infer intent)

---

## **3. Core Functionality: Two-Tier Feedback Extraction**

### **Tier 1: Minimal Feedback (Always Returned)**

Per the paperâ€™s â€œ::Environment Feedbackâ€ section, minimal feedback is **task-specific** and **always** returned, regardless of machine performance.

#### **For `task == "car"`:**
- `machine_orientation`: Orientation of the **root block** (block_id=0) at final timestep.
- `max_moving_distance`: Max displacement of root block along designated direction (e.g., +x axis).
- `max_speed`: Max linear speed of root block during simulation.
- `avg_speed_per_second`: Average speed per second (total distance / 5s).
- `position_per_0_2s`: List of root block positions at each 0.2s interval.

> âœ… **Implementation Logic**:  
> Extract root block (ID=0) trajectory from `state_log`. Compute:
> - Displacement: `max(|x_final - x_initial|)` along x-axis (assuming forward direction is +x)
> - Max speed: `max(velocity_magnitude)` over all timesteps
> - Avg speed: `total_displacement / 5.0`
> - Orientation: quaternion of root at t=5.0s

#### **For `task == "catapult"`:**
- `boulder_max_distance`: Max horizontal distance traveled by **boulder** along designated direction.
- `boulder_max_height`: Max vertical (y) position of **boulder** during simulation.
- `boulder_position_per_0_2s`: List of boulder positions at each 0.2s interval.

> âœ… **Implementation Logic**:  
> Find the block with `type == "Boulder"` in `design`. Extract its trajectory. Compute:
> - `max_distance`: `max(|x|)` over all timesteps (assuming direction = +x)
> - `max_height`: `max(y)` over all timesteps
> - Record full trajectory for potential selective queries

> âš ï¸ **Critical Note**:  
> The paper specifies that `boulder_max_height > 3.0m` is required for `R_valid=True`. This threshold is **not** computed here â€” it is the responsibility of `RewardCalculator`. But `ActiveEnvQuerier` must report `boulder_max_height` so the refiner can reason about it.

### **Tier 2: Selective Queries (Heuristic-Driven)**

These are **dynamic, context-sensitive queries** triggered by observed failure patterns. They return **block-specific state data** for **specific blocks** during **specific time windows**.

#### **Heuristic Rules (Inferred from Paper)**

> *â€œparts during simulation may collide with each other and break. Such behavior carries important hints... an LLM agent... can possibly identify the vulnerable blocksâ€*

We derive the following **deterministic heuristics**:

| Failure Pattern | Trigger Condition | Query Target | Query Type | Time Window |
|-----------------|-------------------|--------------|------------|-------------|
| **Boulder doesn't move** | `boulder_max_distance < 0.5m` AND `boulder_max_height < 0.5m` | `Container` (if exists) | `position`, `orientation`, `velocity` | Entire simulation |
| **Boulder launched but too low** | `boulder_max_height <= 3.0m` | `Boulder`, `Rotating Block`, `Lever` | `position`, `velocity`, `orientation` | Last 1.0s (t=4.0sâ€“5.0s) |
| **Block broke during simulation** | Any blockâ€™s `integrity < 1.0` at any timestep | **Last attached block** (see below) | `position`, `velocity`, `integrity`, `orientation` | From first break to end |
| **Spring collapsed/overextended** | `type == "Spring"` and `length < 0.2` or `length > 2.0` | `Spring` | `length`, `position` | Entire simulation |

> ğŸ” **Why these heuristics?**  
> - **Boulder doesnâ€™t move**: Likely stuck in container or no lever action â†’ query container to see if it moved.  
> - **Boulder too low**: Mechanism lacks power â†’ query propulsion blocks (Rotating Block, Lever) at end to see if they activated.  
> - **Block broke**: Indicates stress concentration â†’ query the **last attached block** (most likely weak point).  
> - **Spring failure**: Direct physical violation â†’ query springâ€™s length and position.

#### **Key Subroutine: Identify â€œLast Attached Blockâ€**

When a block breaks, we need to know **which block was most recently added** in the construction tree, as it is likely structurally unstable.

> âœ… **Algorithm**:
> 1. From `design`, extract the **construction order** (list of blocks by `id`).
> 2. Find the **first block** in this list whose `integrity < 1.0` during simulation.
> 3. Return its `block_id`.
>
> **Rationale**:  
> The construction tree is ordered by attachment sequence. The first block to break is likely the one that was added last in a critical junction, or is under the most stress due to poor attachment.  
> *Example*: If block 7 (a Wooden Rod) breaks, and it was attached to block 5 (a Powered Wheel), and block 7 was the 8th block added â†’ we query block 7.

> âš ï¸ **Edge Case**:  
> If multiple blocks break, query **all** blocks that broke â€” but the paper suggests â€œselectiveâ€ queries. We follow the paperâ€™s intent: **query the first breaking block** as the most indicative failure point.

#### **Query Types (Per Block)**

The `selective_query()` method returns a dict with keys:
```python
{
  "block_id": int,
  "query_types": ["position", "velocity", "orientation", "length"],  # subset
  "time_window": [start_t, end_t],  # e.g., [4.0, 5.0]
  "data": list[dict]  # one entry per timestep in window, with selected fields
}
```

> Example:  
> If a Springâ€™s length drops below 0.2m, return:
> ```python
> {
>   "block_id": 12,
>   "query_types": ["length", "position"],
>   "time_window": [0.0, 5.0],
>   "data": [
>     {"t": 0.0, "length": 1.0, "position": [0.5, 0.3, 0.0]},
>     {"t": 0.2, "length": 0.9, "position": [0.5, 0.3, 0.0]},
>     ...
>   ]
> }
> ```

> âœ… **Data Format**:  
> Each `data` entry is a dict with:
> - `"t"`: time in seconds (timestep index Ã— 0.2)
> - All requested fields (e.g., `"position"`, `"velocity"`, `"length"`) as lists or scalars

---

## **4. Output Format**

The `get_minimal_feedback()` and `selective_query()` methods return **two separate dicts**, which are merged into a single feedback dict for the refiner.

### **Final Feedback Output Structure**
```python
{
  # Minimal feedback (always present)
  "minimal": {
    "task": "catapult",
    "boulder_max_distance": 12.3,
    "boulder_max_height": 2.8,
    "boulder_position_per_0_2s": [[x1,y1,z1], [x2,y2,z2], ...]
  },

  # Selective queries (optional, empty list if none)
  "selective": [
    {
      "block_id": 5,
      "query_types": ["position", "velocity"],
      "time_window": [4.0, 5.0],
      "data": [...]
    },
    {
      "block_id": 12,
      "query_types": ["length"],
      "time_window": [0.0, 5.0],
      "data": [...]
    }
  ],

  # Additional metadata (for debugging/analysis)
  "simulation_status": {
    "intact": True,  # all blocks integrity == 1.0
    "boulder_launched": False,  # boulder_max_height > 0.5
    "root_moved": True
  }
}
```

> âœ… **Why include `simulation_status`?**  
> The paper says â€œthe querier... always provides global information such as machine orientationâ€. This field is an **implicit summary** of key thresholds (e.g., â€œdid the boulder even move?â€) to help the refiner avoid redundant analysis.

---

## **5. Integration with Agent Workflow**

### **Usage in `InspectorRefiner`**
1. `InspectorRefiner` receives a `design` â†’ calls `ActiveEnvQuerier.get_minimal_feedback()` â†’ gets `boulder_max_height=2.8`.
2. Since `2.8 < 3.0`, it knows the design is invalid and **triggers `selective_query()`** on the boulder and its parent blocks.
3. Returns feedback to `Refiner` â†’ Refiner generates revisions: â€œIncrease lever arm lengthâ€ or â€œAdd counterweightâ€.

### **Usage in `Refiner`**
- `Refiner` receives feedback from `InspectorRefiner` â†’ uses `selective` data to guide revision prompts:
  > â€œThe boulder reached only 2.8m height. The Container block at ID=5 had low velocity. Try attaching the lever directly to the Rotating Block instead.â€

### **Heuristic Robustness**
- The heuristics are **simple, deterministic, and interpretable** â€” essential for LLMs to reason from.
- They avoid overfitting: no ML model, no clustering â€” just physics-based rules.
- They scale: adding new block types (e.g., â€œPulleyâ€) requires only adding a new heuristic rule.

---

## **6. Edge Cases and Design Decisions**

| Edge Case | Decision |
|---------|----------|
| **No Boulder in catapult task?** | Treat as invalid. `boulder_max_height = 0`, `boulder_max_distance = 0`. Refiner will be prompted with â€œNo boulder detected.â€ |
| **Multiple Springs break?** | Query **all** broken Springs. But paper says â€œselectiveâ€ â†’ we query only the **first** broken Spring (lowest ID) to avoid overload. |
| **Block ID not found in design?** | Log warning and skip. Should not happen if simulation and tree are synced. |
| **Empty state_log?** | Return empty feedback. Indicates simulation failed to start. |
| **Boulder leaves simulation bounds?** | Continue tracking until end of 5s. Paper implies tracking continues even if boulder flies out. |
| **Powered block didnâ€™t activate?** | Not directly queried â€” inferred from `velocity=0` and `is_powered=True`. Refiner can infer: â€œPowered Wheel didnâ€™t spin.â€ |

---

## **7. Alignment with Configuration**

| Config Key | Usage in `ActiveEnvQuerier` |
|------------|-----------------------------|
| `simulation.duration_seconds: 5` | Used to compute number of timesteps: `5 / 0.2 = 25` |
| `simulation.state_log_interval: 0.2` | Used to map index â†’ time: `t = idx * 0.2` |
| `simulation.catapult_height_threshold: 3.0` | Used to trigger selective queries when `boulder_max_height <= 3.0` |
| `agent.temperature: 0.7` | Not used here â€” used by LLMs in Refiner |
| `agent.top_p: 0.95` | Not used here |
| `agent.search_rounds: 10` | Not used here â€” used by MCTS controller |
| `tasks.catapult.validity_constraints: ["boulder_max_height_gt_3m"]` | Used to infer *why* feedback is needed â€” not for enforcement (thatâ€™s RewardCalculatorâ€™s job) |

> âœ… **All thresholds and intervals are pulled from `config.yaml`** â€” no hardcoding.

---

## **8. Validation and Error Handling**

- **Input Validation**:
  - Ensure `state_log` is a list of dicts with required keys.
  - Ensure `design` is a valid `ConstructionTree` (call `.validate()` if needed).
  - Validate `task` is in `["car", "catapult"]`.

- **Error Handling**:
  - If a block ID in `state_log` is not found in `design`, log warning and skip.
  - If `state_log` has fewer than 25 timesteps, pad with last known state or log error.
  - If no Boulder block is found in catapult task, set `boulder_max_height = 0`, `boulder_max_distance = 0`.

- **Logging**:
  - Use `utils/logger.py` to log:
    - â€œSelective query triggered: Boulder height too low â†’ querying Containerâ€
    - â€œBlock 7 broke at t=2.4s â†’ querying last attached block (ID=7)â€

---

## **9. Summary: Design Principles**

| Principle | Implementation |
|---------|----------------|
| **Minimalism** | Only return essential feedback unless failure detected. |
| **Heuristic-Driven** | No ML, no clustering â€” deterministic rules based on physics anomalies. |
| **LLM-Readable** | Feedback is structured, textual, and matches human reasoning patterns. |
| **Configurable** | All thresholds and intervals from `config.yaml`. |
| **Decoupled** | Does not simulate, does not compute reward â€” only observes and reports. |
| **Extensible** | New block types or failure modes can be added via new heuristic rules. |

---

## **10. Final Output Contract**

```python
class ActiveEnvQuerier:
    def __init__(self, simulator: BesiegeFieldSimulator):
        # Stores reference to simulator for state_log access
        # Also loads BlockRegistry for block type metadata

    def get_minimal_feedback(self, task: str, state_log: list[dict]) -> dict:
        # Returns dict with minimal feedback keys as defined in paper
        # Always returns: task, max_distance, max_height, position_per_0_2s
        # For car: root block metrics
        # For catapult: boulder metrics

    def selective_query(self, design: ConstructionTree, state_log: list[dict]) -> list[dict]:
        # Returns list of query dicts (each with block_id, query_types, time_window, data)
        # Uses heuristics to detect failure patterns
        # Returns empty list if no failures detected

    def get_feedback(self, task: str, design: ConstructionTree, state_log: list[dict]) -> dict:
        # Wrapper: combines minimal + selective into final feedback dict
        # Used by InspectorRefiner and Refiner
        # Returns:
        # {
        #   "minimal": {...},
        #   "selective": [...],
        #   "simulation_status": {...}
        # }
```

> âœ… **This class is stateless and pure** â€” given the same inputs, always returns same output.  
> âœ… **No LLM calls** â€” purely data extraction and rule-based inference.  
> âœ… **No simulation** â€” only consumes simulation output.  

This design ensures that `ActiveEnvQuerier` is **robust, reproducible, and aligned with the paperâ€™s intent**: to provide LLMs with **interpretable, physics-grounded feedback** to guide iterative refinement.