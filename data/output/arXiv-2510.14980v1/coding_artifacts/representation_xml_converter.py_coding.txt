```python
# representation/xml_converter.py
import xml.etree.ElementTree as ET
from typing import List, Dict, Any, Optional, Tuple
from copy import deepcopy
import numpy as np
from utils.config import Config
from representation.construction_tree import ConstructionTree
from env.block_registry import BlockRegistry


class XMLConverter:
    """
    Converts between Besiege's default XML representation (flat, global positions)
    and the structured ConstructionTree representation (relative attachments).
    Implements proximity-based attachment reconstruction as described in the paper.
    """

    def __init__(self):
        """
        Initialize XMLConverter with configuration and block registry.
        Uses collision_threshold from config.yaml for proximity-based attachment detection.
        """
        self.config = Config("config.yaml")
        self.block_registry = BlockRegistry()
        self.collision_threshold = self.config.get("simulation.collision_threshold")
        if not isinstance(self.collision_threshold, float) or self.collision_threshold <= 0:
            raise ValueError("simulation.collision_threshold must be a positive float")

        # Define face normals in local coordinate system for each face_id (0-5)
        # face_id: 0=front(+z), 1=back(-z), 2=left(-x), 3=right(+x), 4=top(+y), 5=bottom(-y)
        self.face_normals = {
            0: np.array([0.0, 0.0, 1.0]),   # +z
            1: np.array([0.0, 0.0, -1.0]),  # -z
            2: np.array([-1.0, 0.0, 0.0]),  # -x
            3: np.array([1.0, 0.0, 0.0]),   # +x
            4: np.array([0.0, 1.0, 0.0]),   # +y
            5: np.array([0.0, -1.0, 0.0])   # -y
        }

        # Define half-size offsets for each block type based on default scale
        # These are used to compute the world position of attachment faces
        # Assumption: blocks are at default scale (no post-construction scaling)
        self.half_sizes = {
            "Starting Block": 0.5,
            "Small Wooden Block": 0.5,
            "Wooden Block": 1.0,     # 2m long (2x1x1), length along z
            "Wooden Rod": 0.5,       # 1m long
            "Log": 1.5,              # 3m long
            "Steering Hinge": 0.5,
            "Steering Block": 0.5,
            "Powered Wheel": 1.0,    # radius=1m
            "Unpowered Wheel": 1.0,
            "Large Powered Wheel": 1.5,  # radius=3m
            "Large Unpowered Wheel": 1.5,
            "Small Wheel": 0.6,      # 1.2m long? Use as offset
            "Roller Wheel": 0.4,     # 0.8m long
            "Universal Joint": 0.5,
            "Hinge": 0.5,
            "Ball Joint": 0.5,
            "Axle Connector": 0.5,
            "Suspension": 0.5,
            "Rotating Block": 0.5,
            "Grabber": 0.5,
            "Boulder": 0.5,
            "Grip Pad": 0.5,
            "Elastic Pad": 0.5,
            "Container": 0.5,
            "Brace": 0.5,
            "Ballast": 0.5
        }
        
        # Special handling for Spring: we assume it has length 1.0m
        # The two endpoints are separated by this length along its axis
        self.spring_length = 1.0

    def from_xml_to_tree(self, xml_str: str) -> ConstructionTree:
        """
        Convert Besiege's default XML representation to ConstructionTree.
        Uses proximity-based attachment reconstruction: if a block's free face is within 
        collision_threshold of an attachable face of a previous block, they are connected.
        
        Args:
            xml_str (str): XML string in Besiege format
            
        Returns:
            ConstructionTree: Validated construction tree in ordered list format
            
        Raises:
            ValueError: If XML is malformed, contains invalid blocks, or cannot be reconstructed
        """
        try:
            root = ET.fromstring(xml_str)
        except ET.ParseError as e:
            raise ValueError(f"Invalid XML format: {str(e)}")

        # Extract all block elements
        block_elements = root.findall(".//block")
        if len(block_elements) == 0:
            raise ValueError("XML contains no block elements")

        # Parse each block into dictionary
        blocks = []
        for i, elem in enumerate(block_elements):
            block_type = elem.get("type")
            if not block_type:
                raise ValueError(f"Block at index {i} has no 'type' attribute")

            # Validate block type
            if block_type not in self.block_registry._valid_block_names:
                raise ValueError(f"Unknown block type '{block_type}' at index {i}")

            # Extract position
            x = float(elem.get("x", 0.0))
            y = float(elem.get("y", 0.0))
            z = float(elem.get("z", 0.0))
            position = [x, y, z]

            # Extract orientation (quaternion)
            qx = float(elem.get("qx", 0.0))
            qy = float(elem.get("qy", 0.0))
            qz = float(elem.get("qz", 0.0))
            qw = float(elem.get("qw", 1.0))
            orientation = [qx, qy, qz, qw]

            # Normalize orientation
            norm = np.linalg.norm(orientation)
            if norm > 1e-6:
                orientation = [x/norm for x in orientation]
            else:
                orientation = [0.0, 0.0, 0.0, 1.0]  # default identity

            # Handle Spring blocks with end_position
            end_position = None
            if block_type == "Spring":
                end_x = elem.get("end_x")
                end_y = elem.get("end_y")
                end_z = elem.get("end_z")
                if end_x is None or end_y is None or end_z is None:
                    raise ValueError(f"Spring block at index {i} must have end_x, end_y, end_z attributes")
                end_position = [float(end_x), float(end_y), float(end_z)]

            # Create block dictionary
            block_dict = {
                "type": block_type,
                "position": position,
                "orientation": orientation,
                "end_position": end_position,
                "index": i  # temporary index for ordering
            }
            blocks.append(block_dict)

        # Sort blocks by index to ensure consistent order
        blocks.sort(key=lambda x: x["index"])
        
        # Validate that we have at least one block
        if len(blocks) == 0:
            raise ValueError("No blocks parsed from XML")

        # Initialize result list for ConstructionTree
        construction_tree = []

        # Process each block to determine parent and face_id
        # We'll use a list to store the parent and face_id for each block
        parent_info = [None] * len(blocks)  # for non-Spring: (parent_id, face_id)
        spring_parents = {}  # for Spring: {block_id: (parent_a_id, face_id_a, parent_b_id, face_id_b)}

        # For each block, find its parent(s) among previous blocks
        for i, block in enumerate(blocks):
            block_type = block["type"]
            position = np.array(block["position"])
            orientation = np.array(block["orientation"])
            
            # For Spring, also get end_position
            end_position = None
            if block_type == "Spring":
                end_position = np.array(block["end_position"])
            
            # Root block must be first and have type "Starting Block"
            if i == 0:
                if block_type != "Starting Block":
                    raise ValueError("First block must be 'Starting Block'")
                # Root block has no parent
                construction_tree.append({
                    "type": block_type,
                    "id": 0,
                    "parent": None,
                    "face_id": None
                })
                continue
            
            # Find parent for non-Spring blocks
            if block_type != "Spring":
                # Get block size for offset calculation
                half_size = self.half_sizes.get(block_type, 0.5)
                
                # Find best parent among all previous blocks (j < i)
                best_parent_id = None
                best_face_id = None
                min_distance = float('inf')
                
                # For each previous block j, check if any of its faces can connect to any of this block's faces
                for j in range(i):
                    parent_block = blocks[j]
                    parent_type = parent_block["type"]
                    parent_pos = np.array(parent_block["position"])
                    parent_ori = np.array(parent_block["orientation"])
                    
                    # Check if parent has attachable faces
                    if self.block_registry.get_attachable_faces(parent_type) == 0:
                        continue  # Skip blocks with no attachable faces (only Spring has 0, but it's not parent)
                    
                    # Get all possible attachment faces on parent
                    for face_id in range(6):
                        # Skip if parent has no attachable face
                        if self.block_registry.get_attachable_faces(parent_type) == 0:
                            continue
                            
                        # Calculate world position of parent's attachment face
                        # Offset from parent's center to its attachment face
                        face_offset_local = self.face_normals[face_id] * self.half_sizes.get(parent_type, 0.5)
                        # Rotate offset by parent's orientation
                        face_offset_world = self._rotate_vector(face_offset_local, parent_ori)
                        # World position of parent's attachment face
                        parent_face_world = parent_pos + face_offset_world
                        
                        # Calculate world position of child's attachment face
                        # The child's attachment face is on the side that connects to parent
                        # We assume the child's attachment face is the one facing the parent
                        # For simplicity, we try all 6 faces of the child
                        for child_face_id in range(6):
                            # Offset from child's center to its attachment face
                            child_face_offset_local = self.face_normals[child_face_id] * half_size
                            # Rotate by child's orientation
                            child_face_offset_world = self._rotate_vector(child_face_offset_local, orientation)
                            # World position of child's attachment face
                            child_face_world = position - child_face_offset_world  # minus because we're connecting inward
                            
                            # Compute distance between parent's face and child's face
                            distance = np.linalg.norm(parent_face_world - child_face_world)
                            
                            # Check if within threshold and better than current best
                            if distance <= self.collision_threshold and distance < min_distance:
                                min_distance = distance
                                best_parent_id = j
                                best_face_id = face_id
                                
                                # We don't need to check other child faces if we found a match
                                # because we want the closest connection
                                break
                        if best_parent_id is not None:
                            break
                    
                    if best_parent_id is not None:
                        break
                
                # If no parent found, invalid construction
                if best_parent_id is None:
                    raise ValueError(f"Block at index {i} (type: {block_type}) has no valid parent attachment")
                
                # Record parent and face_id
                parent_info[i] = (best_parent_id, best_face_id)
                
                # Add to construction tree
                construction_tree.append({
                    "type": block_type,
                    "id": i,
                    "parent": best_parent_id,
                    "face_id": best_face_id
                })
                
            else:  # Spring block
                # Spring has two endpoints: position and end_position
                # We need to find two distinct parent blocks for each endpoint
                
                # Find parent for first endpoint (position)
                parent_a_id = None
                face_id_a = None
                min_distance_a = float('inf')
                
                # Find parent for second endpoint (end_position)
                parent_b_id = None
                face_id_b = None
                min_distance_b = float('inf')
                
                # Check all previous blocks for first endpoint
                for j in range(i):
                    parent_block = blocks[j]
                    parent_type = parent_block["type"]
                    parent_pos = np.array(parent_block["position"])
                    parent_ori = np.array(parent_block["orientation"])
                    
                    # Skip if parent has no attachable faces
                    if self.block_registry.get_attachable_faces(parent_type) == 0:
                        continue
                    
                    # Check each face of parent for first endpoint
                    for face_id in range(6):
                        # Calculate world position of parent's attachment face
                        face_offset_local = self.face_normals[face_id] * self.half_sizes.get(parent_type, 0.5)
                        face_offset_world = self._rotate_vector(face_offset_local, parent_ori)
                        parent_face_world = parent_pos + face_offset_world
                        
                        # Distance from first endpoint to parent's face
                        distance = np.linalg.norm(parent_face_world - position)
                        
                        if distance <= self.collision_threshold and distance < min_distance_a:
                            min_distance_a = distance
                            parent_a_id = j
                            face_id_a = face_id
                
                # Check all previous blocks for second endpoint
                for j in range(i):
                    parent_block = blocks[j]
                    parent_type = parent_block["type"]
                    parent_pos = np.array(parent_block["position"])
                    parent_ori = np.array(parent_block["orientation"])
                    
                    # Skip if parent has no attachable faces
                    if self.block_registry.get_attachable_faces(parent_type) == 0:
                        continue
                    
                    # Check each face of parent for second endpoint
                    for face_id in range(6):
                        # Calculate world position of parent's attachment face
                        face_offset_local = self.face_normals[face_id] * self.half_sizes.get(parent_type, 0.5)
                        face_offset_world = self._rotate_vector(face_offset_local, parent_ori)
                        parent_face_world = parent_pos + face_offset_world
                        
                        # Distance from second endpoint to parent's face
                        distance = np.linalg.norm(parent_face_world - end_position)
                        
                        if distance <= self.collision_threshold and distance < min_distance_b:
                            min_distance_b = distance
                            parent_b_id = j
                            face_id_b = face_id
                
                # Validate that we found two distinct parents
                if parent_a_id is None:
                    raise ValueError(f"Spring block at index {i} has no valid parent for first endpoint")
                if parent_b_id is None:
                    raise ValueError(f"Spring block at index {i} has no valid parent for second endpoint")
                if parent_a_id == parent_b_id:
                    raise ValueError(f"Spring block at index {i} cannot have same block as both parents")
                
                # Record spring parents
                spring_parents[i] = (parent_a_id, face_id_a, parent_b_id, face_id_b)
                
                # Add to construction tree
                construction_tree.append({
                    "type": block_type,
                    "id": i,
                    "parent_a": parent_a_id,
                    "parent_b": parent_b_id,
                    "face_id_a": face_id_a,
                    "face_id_b": face_id_b
                })
        
        # Validate that we have a valid construction tree
        # Check that first block is Starting Block
        if len(construction_tree) == 0 or construction_tree[0]["type"] != "Starting Block":
            raise ValueError("Construction tree must start with 'Starting Block'")
        
        # Check that all IDs are contiguous from 0 to N-1
        for i, block in enumerate(construction_tree):
            if block["id"] != i:
                raise ValueError(f"Block IDs must be contiguous from 0 to {len(construction_tree)-1}, got {block['id']} at index {i}")
        
        # Create and return ConstructionTree
        ct = ConstructionTree(construction_tree, self.block_registry)
        if not ct.is_valid():
            raise ValueError(f"Constructed tree is invalid: {ct.get_validation_error()}")
        
        return ct

    def from_tree_to_xml(self, tree: ConstructionTree) -> str:
        """
        Convert ConstructionTree back to Besiege's default XML representation.
        Reconstructs global positions and orientations from the relative attachment tree.
        
        Args:
            tree (ConstructionTree): Valid construction tree
            
        Returns:
            str: XML string in Besiege format
            
        Raises:
            ValueError: If tree is invalid
        """
        if not tree.is_valid():
            raise ValueError(f"Cannot convert invalid construction tree to XML: {tree.get_validation_error()}")
        
        # Get construction tree data
        blocks_data = tree.to_json()
        
        # Create root element
        root = ET.Element("blocks")
        
        # Track global positions and orientations for each block
        # We'll compute these recursively from the root
        global_positions = {}
        global_orientations = {}
        
        # Process blocks in order (0 to N-1)
        for block in blocks_data:
            block_id = block["id"]
            block_type = block["type"]
            
            # Root block
            if block_id == 0:
                # Starting Block at origin with identity orientation
                global_positions[block_id] = np.array([0.0, 0.0, 0.0])
                global_orientations[block_id] = np.array([0.0, 0.0, 0.0, 1.0])
                continue
            
            # Get parent and face_id information
            if "parent_a" in block and "parent_b" in block:
                # Spring block - handle separately
                parent_a_id = block["parent_a"]
                parent_b_id = block["parent_b"]
                face_id_a = block["face_id_a"]
                face_id_b = block["face_id_b"]
                
                # Get parent positions and orientations
                parent_a_pos = global_positions[parent_a_id]
                parent_a_ori = global_orientations[parent_a_id]
                parent_b_pos = global_positions[parent_b_id]
                parent_b_ori = global_orientations[parent_b_id]
                
                # Calculate position of first endpoint (attached to parent_a)
                # Offset from parent_a's attachment face
                parent_a_half_size = self.half_sizes.get(self.block_registry.get_block_info(block_type)["type"], 0.5)
                face_offset_local_a = self.face_normals[face_id_a] * parent_a_half_size
                face_offset_world_a = self._rotate_vector(face_offset_local_a, parent_a_ori)
                endpoint_a_pos = parent_a_pos + face_offset_world_a
                
                # Calculate position of second endpoint (attached to parent_b)
                parent_b_half_size = self.half_sizes.get(self.block_registry.get_block_info(block_type)["type"], 0.5)
                face_offset_local_b = self.face_normals[face_id_b] * parent_b_half_size
                face_offset_world_b = self._rotate_vector(face_offset_local_b, parent_b_ori)
                endpoint_b_pos = parent_b_pos + face_offset_world_b
                
                # For Spring, we use the first endpoint as the block's position
                # and the second endpoint as end_position
                global_positions[block_id] = endpoint_a_pos
                global_orientations[block_id] = np.array([0.0, 0.0, 0.0, 1.0])  # Spring has no orientation
                
                # Create XML element for Spring
                block_elem = ET.SubElement(root, "block")
                block_elem.set("type", block_type)
                block_elem.set("x", f"{endpoint_a_pos[0]:.6f}")
                block_elem.set("y", f"{endpoint_a_pos[1]:.6f}")
                block_elem.set("z", f"{endpoint_a_pos[2]:.6f}")
                block_elem.set("qx", "0.0")
                block_elem.set("qy", "0.0")
                block_elem.set("qz", "0.0")
                block_elem.set("qw", "1.0")
                block_elem.set("end_x", f"{endpoint_b_pos[0]:.6f}")
                block_elem.set("end_y", f"{endpoint_b_pos[1]:.6f}")
                block_elem.set("end_z", f"{endpoint_b_pos[2]:.6f}")
                
            else:
                # Regular block with single parent
                parent_id = block["parent"]
                face_id = block["face_id"]
                
                # Get parent position and orientation
                parent_pos = global_positions[parent_id]
                parent_ori = global_orientations[parent_id]
                
                # Get half-size of this block
                half_size = self.half_sizes.get(block_type, 0.5)
                
                # Calculate the offset from parent's attachment face to child's attachment point
                # The child's attachment face is oriented toward the parent
                # So we need to rotate the child's local face normal by parent's orientation
                face_offset_local = self.face_normals[face_id] * half_size
                face_offset_world = self._rotate_vector(face_offset_local, parent_ori)
                
                # The child's position is the parent's attachment face position minus the offset
                # This places the child's attachment face exactly at the parent's attachment face
                child_pos = parent_pos + face_offset_world
                
                # For orientation: the child's local z-axis should align with the attachment direction
                # We assume the child's local z-axis is aligned with the parent's attachment face normal
                # So we need to compute the rotation that aligns [0,0,1] with the attachment direction
                attachment_direction = self.face_normals[face_id]
                child_orientation = self._compute_orientation_for_attachment(attachment_direction)
                
                # Store global position and orientation
                global_positions[block_id] = child_pos
                global_orientations[block_id] = child_orientation
                
                # Create XML element for regular block
                block_elem = ET.SubElement(root, "block")
                block_elem.set("type", block_type)
                block_elem.set("x", f"{child_pos[0]:.6f}")
                block_elem.set("y", f"{child_pos[1]:.6f}")
                block_elem.set("z", f"{child_pos[2]:.6f}")
                block_elem.set("qx", f"{child_orientation[0]:.6f}")
                block_elem.set("qy", f"{child_orientation[1]:.6f}")
                block_elem.set("qz", f"{child_orientation[2]:.6f}")
                block_elem.set("qw", f"{child_orientation[3]:.6f}")
        
        # Convert to string
        xml_str = ET.tostring(root, encoding='unicode')
        return xml_str
    
    def _rotate_vector(self, vector: np.ndarray, quaternion: np.ndarray) -> np.ndarray:
        """
        Rotate a 3D vector by a quaternion.
        
        Args:
            vector: np.ndarray of shape (3,)
            quaternion: np.ndarray of shape (4,) [qx, qy, qz, qw]
            
        Returns:
            np.ndarray: rotated vector of shape (3,)
        """
        # Normalize quaternion
        q = quaternion / np.linalg.norm(quaternion)
        qx, qy, qz, qw = q
        
        # Quaternion rotation formula: v' = q * v * q_conj
        # Using formula: v' = v + 2 * cross(q_vec, cross(q_vec, v) + qw * v)
        q_vec = q[:3]
        v = vector
        
        # First cross product: cross(q_vec, v)
        cross1 = np.cross(q_vec, v)
        # Second cross product: cross(q_vec, cross1) + qw * v
        cross2 = np.cross(q_vec, cross1) + qw * v
        # Final result
        result = v + 2.0 * cross2
        
        return result

    def _compute_orientation_for_attachment(self, attachment_direction: np.ndarray) -> np.ndarray:
        """
        Compute a quaternion that rotates the local z-axis [0,0,1] to align with the attachment_direction.
        
        Args:
            attachment_direction: np.ndarray of shape (3,) - target direction
            
        Returns:
            np.ndarray: quaternion [qx, qy, qz, qw] that rotates [0,0,1] to attachment_direction
        """
        # Normalize the attachment direction
        target = attachment_direction / np.linalg.norm(attachment_direction)
        
        # The source direction is [0,0,1]
        source = np.array([0.0, 0.0, 1.0])
        
        # Handle case where source and target are parallel
        dot = np.dot(source, target)
        if dot > 0.9999:
            # Already aligned
            return np.array([0.0, 0.0, 0.0, 1.0])
        elif dot < -0.9999:
            # Opposite direction: rotate 180Â° around any perpendicular axis
            # Choose an arbitrary perpendicular axis
            if np.abs(source[0]) < 0.9:
                axis = np.cross(source, [1.0, 0.0, 0.0])
            else:
                axis = np.cross(source, [0.0, 1.0, 0.0])
            axis = axis / np.linalg.norm(axis)
            angle = np.pi
            return self._axis_angle_to_quaternion(axis, angle)
        
        # General case: find rotation axis and angle
        axis = np.cross(source, target)
        axis = axis / np.linalg.norm(axis)
        angle = np.arccos(dot)
        
        return self._axis_angle_to_quaternion(axis, angle)
    
    def _axis_angle_to_quaternion(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """
        Convert axis-angle representation to quaternion.
        
        Args:
            axis: np.ndarray of shape (3,) - rotation axis
            angle: float - rotation angle in radians
            
        Returns:
            np.ndarray: quaternion [qx, qy, qz, qw]
        """
        half_angle = angle / 2.0
        sin_half = np.sin(half_angle)
        cos_half = np.cos(half_angle)
        
        qx = axis[0] * sin_half
        qy = axis[1] * sin_half
        qz = axis[2] * sin_half
        qw = cos_half
        
        return np.array([qx, qy, qz, qw])
```