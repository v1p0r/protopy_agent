```python
# eval/visualizer.py
import os
import json
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from typing import List, Dict, Any, Optional, Tuple
from utils.config import Config
from utils.logger import Logger
from representation.construction_tree import ConstructionTree
from env.block_registry import BlockRegistry


class Visualizer:
    """
    Renders 3D visualizations of machine designs from ConstructionTree objects.
    Uses matplotlib as fallback renderer; can be extended to Unity3D plugin if available.
    Generates PNG/PDF visualizations for qualitative analysis and publication.
    """

    def __init__(self, config: Optional[Config] = None):
        """
        Initialize the Visualizer with configuration and block geometry definitions.
        
        Args:
            config (Config, optional): Configuration loader. If None, loads from "config.yaml"
        """
        self.config = config or Config("config.yaml")
        self.logger = Logger(__name__)
        
        # Load configuration values
        self.visualizations_dir = self.config.get("output.visualizations_dir", "visualizations")
        self.simulation_duration = self.config.get("simulation.duration_seconds", 5.0)
        
        # Ensure output directory exists
        if not os.path.exists(self.visualizations_dir):
            os.makedirs(self.visualizations_dir, exist_ok=True)
            self.logger.info(f"Created visualizations directory: {self.visualizations_dir}")
        
        # Initialize block registry for geometry lookup
        self.block_registry = BlockRegistry()
        
        # Define block geometry: (width, height, depth) in meters for cuboid approximation
        # Based on Besiege's default scales and paper descriptions
        self.BLOCK_GEOMETRY = {
            "Starting Block": (1.0, 1.0, 1.0),
            "Small Wooden Block": (1.0, 1.0, 1.0),
            "Wooden Block": (2.0, 1.0, 1.0),  # Two small blocks attached along length
            "Wooden Rod": (0.2, 0.2, 2.0),    # Slender rod
            "Log": (1.0, 1.0, 3.0),           # Three small blocks in parallel
            "Steering Hinge": (1.0, 1.0, 1.0),
            "Steering Block": (1.0, 1.0, 1.0),
            "Powered Wheel": (2.0, 2.0, 2.0), # Radius 1m → diameter 2m
            "Unpowered Wheel": (2.0, 2.0, 2.0),
            "Large Powered Wheel": (6.0, 6.0, 6.0), # Radius 3m → diameter 6m
            "Large Unpowered Wheel": (6.0, 6.0, 6.0),
            "Small Wheel": (1.0, 1.0, 1.2),   # Length 1.2m
            "Roller Wheel": (1.0, 1.0, 0.8),  # Length 0.8m
            "Universal Joint": (1.0, 1.0, 1.0),
            "Hinge": (1.0, 1.0, 1.0),
            "Ball Joint": (1.0, 1.0, 1.0),
            "Axle Connector": (1.0, 1.0, 1.0),
            "Suspension": (1.0, 1.0, 1.0),
            "Rotating Block": (1.0, 1.0, 1.0),
            "Grabber": (1.0, 1.0, 1.0),
            "Boulder": (1.5, 1.5, 1.5),       # Large rock
            "Grip Pad": (1.0, 1.0, 1.0),
            "Elastic Pad": (1.0, 1.0, 1.0),
            "Container": (1.0, 1.0, 1.0),
            "Spring": (0.1, 0.1, 1.0),        # Thin cylinder for visualization (length=1m)
            "Brace": (0.5, 0.5, 1.5),         # Thin reinforcement
            "Ballast": (1.0, 1.0, 1.0)        # Heavy cube
        }
        
        # Define color mapping by block type for visual distinction
        self.BLOCK_COLORS = {
            "Starting Block": "red",           # Highlight root
            "Small Wooden Block": "#8B4513",   # SaddleBrown (wood)
            "Wooden Block": "#8B4513",         # SaddleBrown
            "Wooden Rod": "#8B4513",           # SaddleBrown
            "Log": "#8B4513",                  # SaddleBrown
            "Steering Hinge": "#8B4513",       # SaddleBrown
            "Steering Block": "#8B4513",       # SaddleBrown
            "Powered Wheel": "blue",           # Powered
            "Unpowered Wheel": "#A9A9A9",      # DarkGray
            "Large Powered Wheel": "blue",     # Powered
            "Large Unpowered Wheel": "#A9A9A9",# DarkGray
            "Small Wheel": "#A9A9A9",          # DarkGray
            "Roller Wheel": "#A9A9A9",         # DarkGray
            "Universal Joint": "#8B4513",      # SaddleBrown
            "Hinge": "#8B4513",                # SaddleBrown
            "Ball Joint": "#8B4513",           # SaddleBrown
            "Axle Connector": "#8B4513",       # SaddleBrown
            "Suspension": "green",             # Special
            "Rotating Block": "blue",          # Powered
            "Grabber": "#8B4513",              # SaddleBrown
            "Boulder": "#654321",              # Chocolate (rock)
            "Grip Pad": "#696969",             # DimGray
            "Elastic Pad": "#98FB98",          # PaleGreen
            "Container": "#ADD8E6",            # LightBlue
            "Spring": "green",                 # Special
            "Brace": "#8B4513",                # SaddleBrown
            "Ballast": "#2F4F4F",              # DarkSlateGray
        }
        
        # Define block rendering type: "box", "cylinder", or "line"
        self.BLOCK_RENDER_TYPE = {
            "Starting Block": "box",
            "Small Wooden Block": "box",
            "Wooden Block": "box",
            "Wooden Rod": "cylinder",
            "Log": "box",
            "Steering Hinge": "box",
            "Steering Block": "box",
            "Powered Wheel": "cylinder",
            "Unpowered Wheel": "cylinder",
            "Large Powered Wheel": "cylinder",
            "Large Unpowered Wheel": "cylinder",
            "Small Wheel": "cylinder",
            "Roller Wheel": "cylinder",
            "Universal Joint": "box",
            "Hinge": "box",
            "Ball Joint": "box",
            "Axle Connector": "box",
            "Suspension": "box",
            "Rotating Block": "box",
            "Grabber": "box",
            "Boulder": "box",
            "Grip Pad": "box",
            "Elastic Pad": "box",
            "Container": "box",
            "Spring": "line",                  # Special: line between two points
            "Brace": "cylinder",
            "Ballast": "box"
        }
        
        # Define cylinder dimensions (for wheels and rods)
        # For cylinders: radius and height
        self.CYLINDER_DIMENSIONS = {
            "Powered Wheel": {"radius": 1.0, "height": 0.2},   # radius=1m, height=0.2m
            "Unpowered Wheel": {"radius": 1.0, "height": 0.2},
            "Large Powered Wheel": {"radius": 3.0, "height": 0.2},
            "Large Unpowered Wheel": {"radius": 3.0, "height": 0.2},
            "Small Wheel": {"radius": 0.6, "height": 0.2},     # radius=0.6m (half of 1.2m length)
            "Roller Wheel": {"radius": 0.4, "height": 0.2},    # radius=0.4m (half of 0.8m length)
            "Wooden Rod": {"radius": 0.1, "height": 2.0},      # radius=0.1m, height=2m
            "Brace": {"radius": 0.25, "height": 1.5},          # radius=0.25m, height=1.5m
        }
        
        # Define line properties for Spring
        self.SPRING_LINE_WIDTH = 2.0
        self.SPRING_COLOR = "green"
        
        # Validate that all block types have geometry and color definitions
        valid_blocks = set(self.block_registry._valid_block_names)
        missing_blocks = valid_blocks - set(self.BLOCK_GEOMETRY.keys())
        if missing_blocks:
            self.logger.warning(f"Missing geometry definitions for blocks: {missing_blocks}")
            for block in missing_blocks:
                self.BLOCK_GEOMETRY[block] = (1.0, 1.0, 1.0)
                self.BLOCK_COLORS[block] = "#CCCCCC"
                self.BLOCK_RENDER_TYPE[block] = "box"
                
        # Ensure all blocks have render type
        missing_render = valid_blocks - set(self.BLOCK_RENDER_TYPE.keys())
        if missing_render:
            self.logger.warning(f"Missing render type definitions for blocks: {missing_render}")
            for block in missing_render:
                self.BLOCK_RENDER_TYPE[block] = "box"
                
        # Ensure all blocks have color
        missing_colors = valid_blocks - set(self.BLOCK_COLORS.keys())
        if missing_colors:
            self.logger.warning(f"Missing color definitions for blocks: {missing_colors}")
            for block in missing_colors:
                self.BLOCK_COLORS[block] = "#CCCCCC"
                
        # Ensure all cylinders have dimensions
        for block in self.BLOCK_RENDER_TYPE:
            if self.BLOCK_RENDER_TYPE[block] == "cylinder" and block not in self.CYLINDER_DIMENSIONS:
                self.logger.warning(f"Cylinder block {block} has no dimensions defined. Using default.")
                self.CYLINDER_DIMENSIONS[block] = {"radius": 0.5, "height": 1.0}

    def _compute_block_transform(self, parent_pos: np.ndarray, parent_ori: np.ndarray, 
                               child_type: str, face_id: int) -> Tuple[np.ndarray, np.ndarray]:
        """
        Compute the global position and orientation of a child block based on its parent's pose and attachment face.
        
        Args:
            parent_pos: np.ndarray of shape (3,) - parent's global position
            parent_ori: np.ndarray of shape (4,) - parent's orientation as quaternion [qx, qy, qz, qw]
            child_type: str - type of child block
            face_id: int - face index (0-5) on parent for attachment
            
        Returns:
            Tuple[np.ndarray, np.ndarray]: (child_pos, child_ori) in global coordinates
        """
        # Get child block geometry
        width, height, depth = self.BLOCK_GEOMETRY[child_type]
        half_width, half_height, half_depth = width/2, height/2, depth/2
        
        # Define face normals in parent's local coordinate system
        # face_id: 0=front(+Z), 1=back(-Z), 2=left(-X), 3=right(+X), 4=top(+Y), 5=bottom(-Y)
        face_normals = {
            0: np.array([0, 0, 1]),   # front
            1: np.array([0, 0, -1]),  # back
            2: np.array([-1, 0, 0]),  # left
            3: np.array([1, 0, 0]),   # right
            4: np.array([0, 1, 0]),   # top
            5: np.array([0, -1, 0])   # bottom
        }
        
        # Offset from parent's center to attachment point (in parent's local coordinates)
        # Attachment point is at the center of the face
        offset_local = face_normals[face_id] * {
            0: half_depth,  # front
            1: half_depth,  # back
            2: half_width,  # left
            3: half_width,  # right
            4: half_height, # top
            5: half_height  # bottom
        }[face_id]
        
        # Transform offset to global coordinates
        offset_global = self._rotate_vector(offset_local, parent_ori)
        child_pos = parent_pos + offset_global
        
        # Compute child's orientation: align child's local +Z with the attachment direction
        # Child's local +Z should point in the direction of the attachment normal
        target_direction = face_normals[face_id]
        
        # Compute rotation to align [0,0,1] with target_direction
        source_direction = np.array([0, 0, 1])
        dot_product = np.dot(source_direction, target_direction)
        
        # Handle parallel cases
        if abs(dot_product) > 0.9999:
            if dot_product > 0:
                # Already aligned
                child_ori = parent_ori
            else:
                # Opposite direction: rotate 180 degrees around any perpendicular axis
                if abs(source_direction[0]) < 0.9:
                    axis = np.cross(source_direction, [1, 0, 0])
                else:
                    axis = np.cross(source_direction, [0, 1, 0])
                axis = axis / np.linalg.norm(axis)
                angle = np.pi
                child_ori = self._axis_angle_to_quaternion(axis, angle)
        else:
            # General case
            axis = np.cross(source_direction, target_direction)
            axis = axis / np.linalg.norm(axis)
            angle = np.arccos(dot_product)
            child_ori = self._axis_angle_to_quaternion(axis, angle)
            
            # Combine with parent's orientation: child_ori = parent_ori * child_ori
            child_ori = self._quaternion_multiply(parent_ori, child_ori)
            
        return child_pos, child_ori

    def _rotate_vector(self, vector: np.ndarray, quaternion: np.ndarray) -> np.ndarray:
        """
        Rotate a 3D vector by a quaternion.
        
        Args:
            vector: np.ndarray of shape (3,)
            quaternion: np.ndarray of shape (4,) [qx, qy, qz, qw]
            
        Returns:
            np.ndarray: rotated vector of shape (3,)
        """
        # Normalize quaternion
        q = quaternion / np.linalg.norm(quaternion)
        qx, qy, qz, qw = q
        
        # Quaternion rotation formula: v' = q * v * q_conj
        # Using formula: v' = v + 2 * cross(q_vec, cross(q_vec, v) + qw * v)
        q_vec = q[:3]
        v = vector
        
        # First cross product: cross(q_vec, v)
        cross1 = np.cross(q_vec, v)
        # Second cross product: cross(q_vec, cross1) + qw * v
        cross2 = np.cross(q_vec, cross1) + qw * v
        # Final result
        result = v + 2.0 * cross2
        
        return result

    def _quaternion_multiply(self, q1: np.ndarray, q2: np.ndarray) -> np.ndarray:
        """
        Multiply two quaternions: q1 * q2
        
        Args:
            q1: np.ndarray of shape (4,) [qx, qy, qz, qw]
            q2: np.ndarray of shape (4,) [qx, qy, qz, qw]
            
        Returns:
            np.ndarray: product quaternion of shape (4,)
        """
        w1, x1, y1, z1 = q1[3], q1[0], q1[1], q1[2]
        w2, x2, y2, z2 = q2[3], q2[0], q2[1], q2[2]
        
        w = w1*w2 - x1*x2 - y1*y2 - z1*z2
        x = w1*x2 + x1*w2 + y1*z2 - z1*y2
        y = w1*y2 - x1*z2 + y1*w2 + z1*x2
        z = w1*z2 + x1*y2 - y1*x2 + z1*w2
        
        return np.array([x, y, z, w])

    def _axis_angle_to_quaternion(self, axis: np.ndarray, angle: float) -> np.ndarray:
        """
        Convert axis-angle representation to quaternion.
        
        Args:
            axis: np.ndarray of shape (3,) - rotation axis
            angle: float - rotation angle in radians
            
        Returns:
            np.ndarray: quaternion [qx, qy, qz, qw]
        """
        half_angle = angle / 2.0
        sin_half = np.sin(half_angle)
        cos_half = np.cos(half_angle)
        
        qx = axis[0] * sin_half
        qy = axis[1] * sin_half
        qz = axis[2] * sin_half
        qw = cos_half
        
        return np.array([qx, qy, qz, qw])

    def _render_box(self, ax: Axes3D, position: np.ndarray, orientation: np.ndarray, 
                    width: float, height: float, depth: float, color: str) -> None:
        """
        Render a box (cuboid) at the specified position and orientation.
        
        Args:
            ax: matplotlib 3D axes
            position: np.ndarray of shape (3,) - center position
            orientation: np.ndarray of shape (4,) - quaternion orientation
            width, height, depth: dimensions in meters
            color: matplotlib color string
        """
        # Define 8 corners of the box in local coordinates
        half_w, half_h, half_d = width/2, height/2, depth/2
        corners_local = np.array([
            [-half_w, -half_h, -half_d],
            [ half_w, -half_h, -half_d],
            [ half_w,  half_h, -half_d],
            [-half_w,  half_h, -half_d],
            [-half_w, -half_h,  half_d],
            [ half_w, -half_h,  half_d],
            [ half_w,  half_h,  half_d],
            [-half_w,  half_h,  half_d]
        ])
        
        # Rotate corners by quaternion
        corners_global = np.zeros_like(corners_local)
        for i, corner in enumerate(corners_local):
            corners_global[i] = self._rotate_vector(corner, orientation)
            
        # Translate to position
        corners_global += position
        
        # Define 6 faces of the box
        faces = [
            [corners_global[0], corners_global[1], corners_global[2], corners_global[3]],  # bottom
            [corners_global[4], corners_global[7], corners_global[6], corners_global[5]],  # top
            [corners_global[0], corners_global[4], corners_global[5], corners_global[1]],  # front
            [corners_global[2], corners_global[6], corners_global[7], corners_global[3]],  # back
            [corners_global[0], corners_global[3], corners_global[7], corners_global[4]],  # left
            [corners_global[1], corners_global[5], corners_global[6], corners_global[2]]   # right
        ]
        
        # Create Poly3DCollection
        box = Poly3DCollection(faces, alpha=0.8, linewidths=1, edgecolors='k', facecolors=color)
        ax.add_collection3d(box)

    def _render_cylinder(self, ax: Axes3D, position: np.ndarray, orientation: np.ndarray, 
                         radius: float, height: float, color: str) -> None:
        """
        Render a cylinder at the specified position and orientation.
        
        Args:
            ax: matplotlib 3D axes
            position: np.ndarray of shape (3,) - center position
            orientation: np.ndarray of shape (4,) - quaternion orientation
            radius: float - radius in meters
            height: float - height in meters
            color: matplotlib color string
        """
        # Generate cylinder points in local coordinates (aligned with Z-axis)
        n = 20  # number of points around circumference
        theta = np.linspace(0, 2*np.pi, n)
        z = np.array([-height/2, height/2])
        
        # Create meshgrid
        theta_grid, z_grid = np.meshgrid(theta, z)
        x = radius * np.cos(theta_grid)
        y = radius * np.sin(theta_grid)
        
        # Flatten arrays
        x_flat = x.flatten()
        y_flat = y.flatten()
        z_flat = z_grid.flatten()
        
        # Stack into points
        points_local = np.vstack([x_flat, y_flat, z_flat]).T  # shape (n*2, 3)
        
        # Rotate points by quaternion
        points_global = np.zeros_like(points_local)
        for i, point in enumerate(points_local):
            points_global[i] = self._rotate_vector(point, orientation)
            
        # Translate to position
        points_global += position
        
        # Reshape back to meshgrid
        x_global = points_global[:, 0].reshape(n, 2)
        y_global = points_global[:, 1].reshape(n, 2)
        z_global = points_global[:, 2].reshape(n, 2)
        
        # Plot surface
        ax.plot_surface(x_global, y_global, z_global, alpha=0.8, color=color, linewidth=0)
        
        # Draw top and bottom circles
        theta_circle = np.linspace(0, 2*np.pi, n)
        x_circle = radius * np.cos(theta_circle)
        y_circle = radius * np.sin(theta_circle)
        
        # Bottom circle
        z_bottom = np.full_like(theta_circle, -height/2)
        points_bottom = np.vstack([x_circle, y_circle, z_bottom]).T
        points_bottom_global = np.zeros_like(points_bottom)
        for i, point in enumerate(points_bottom):
            points_bottom_global[i] = self._rotate_vector(point, orientation)
        points_bottom_global += position
        ax.plot(points_bottom_global[:, 0], points_bottom_global[:, 1], points_bottom_global[:, 2], color=color, linewidth=1)
        
        # Top circle
        z_top = np.full_like(theta_circle, height/2)
        points_top = np.vstack([x_circle, y_circle, z_top]).T
        points_top_global = np.zeros_like(points_top)
        for i, point in enumerate(points_top):
            points_top_global[i] = self._rotate_vector(point, orientation)
        points_top_global += position
        ax.plot(points_top_global[:, 0], points_top_global[:, 1], points_top_global[:, 2], color=color, linewidth=1)

    def _render_line(self, ax: Axes3D, start_pos: np.ndarray, end_pos: np.ndarray, 
                     color: str, linewidth: float = 2.0) -> None:
        """
        Render a line segment between two points.
        
        Args:
            ax: matplotlib 3D axes
            start_pos: np.ndarray of shape (3,) - start point
            end_pos: np.ndarray of shape (3,) - end point
            color: matplotlib color string
            linewidth: float - line width
        """
        ax.plot([start_pos[0], end_pos[0]], 
                [start_pos[1], end_pos[1]], 
                [start_pos[2], end_pos[2]], 
                color=color, linewidth=linewidth)

    def render_machine(self, tree: ConstructionTree, output_path: Optional[str] = None, 
                      task: str = "car", prompt_id: int = 0, machine_id: int = 0) -> None:
        """
        Render a machine design from a ConstructionTree to a 3D visualization.
        
        Args:
            tree (ConstructionTree): Valid construction tree to render
            output_path (str, optional): Path to save the visualization. If None, generates path automatically.
            task (str): Task type ("car" or "catapult") for filename
            prompt_id (int): Prompt index for filename
            machine_id (int): Machine index for filename
            
        Returns:
            None - saves visualization to file
            
        Raises:
            ValueError: If tree is invalid
        """
        # Validate tree
        is_valid, error_msg = tree.validate()
        if not is_valid:
            raise ValueError(f"Cannot render invalid construction tree: {error_msg}")
            
        # Get blocks data
        blocks_data = tree.to_json()
        
        # Initialize 3D plot
        fig = plt.figure(figsize=(12, 10))
        ax = fig.add_subplot(111, projection='3d')
        
        # Set labels and title
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title(f'{task.capitalize()} Machine Design (Prompt {prompt_id}, Machine {machine_id})')
        
        # Track block positions and orientations
        block_positions = {}
        block_orientations = {}
        
        # Process blocks in order (construction sequence)
        for block in blocks_data:
            block_id = block["id"]
            block_type = block["type"]
            
            # Root block
            if block_id == 0:
                # Starting Block at origin with identity orientation
                position = np.array([0.0, 0.0, 0.0])
                orientation = np.array([0.0, 0.0, 0.0, 1.0])
                
                block_positions[block_id] = position
                block_orientations[block_id] = orientation
                
                # Render root block
                width, height, depth = self.BLOCK_GEOMETRY[block_type]
                color = self.BLOCK_COLORS[block_type]
                render_type = self.BLOCK_RENDER_TYPE[block_type]
                
                if render_type == "box":
                    self._render_box(ax, position, orientation, width, height, depth, color)
                elif render_type == "cylinder":
                    radius = self.CYLINDER_DIMENSIONS[block_type]["radius"]
                    height_val = self.CYLINDER_DIMENSIONS[block_type]["height"]
                    self._render_cylinder(ax, position, orientation, radius, height_val, color)
                elif render_type == "line":
                    # Shouldn't happen for Starting Block
                    pass
                    
                continue
                
            # Non-root block
            if "parent_a" in block and "parent_b" in block:
                # Spring block - render as line between two parents
                parent_a_id = block["parent_a"]
                parent_b_id = block["parent_b"]
                
                # Get parent positions
                if parent_a_id not in block_positions or parent_b_id not in block_positions:
                    self.logger.warning(f"Spring block {block_id} connected to unrendered parents {parent_a_id}, {parent_b_id}")
                    continue
                    
                start_pos = block_positions[parent_a_id]
                end_pos = block_positions[parent_b_id]
                
                # Render spring as line
                self._render_line(ax, start_pos, end_pos, self.SPRING_COLOR, self.SPRING_LINE_WIDTH)
                
                # Calculate and store spring center for reference
                spring_pos = (start_pos + end_pos) / 2
                block_positions[block_id] = spring_pos
                block_orientations[block_id] = np.array([0.0, 0.0, 0.0, 1.0])  # Default orientation
                
            else:
                # Regular block with single parent
                parent_id = block["parent"]
                face_id = block["face_id"]
                
                # Check if parent has been rendered
                if parent_id not in block_positions:
                    self.logger.warning(f"Block {block_id} (type: {block_type}) has unrendered parent {parent_id}")
                    continue
                    
                parent_pos = block_positions[parent_id]
                parent_ori = block_orientations[parent_id]
                
                # Compute child's global position and orientation
                child_pos, child_ori = self._compute_block_transform(parent_pos, parent_ori, block_type, face_id)
                
                # Store for future children
                block_positions[block_id] = child_pos
                block_orientations[block_id] = child_ori
                
                # Render the block
                width, height, depth = self.BLOCK_GEOMETRY[block_type]
                color = self.BLOCK_COLORS[block_type]
                render_type = self.BLOCK_RENDER_TYPE[block_type]
                
                if render_type == "box":
                    self._render_box(ax, child_pos, child_ori, width, height, depth, color)
                elif render_type == "cylinder":
                    radius = self.CYLINDER_DIMENSIONS[block_type]["radius"]
                    height_val = self.CYLINDER_DIMENSIONS[block_type]["height"]
                    self._render_cylinder(ax, child_pos, child_ori, radius, height_val, color)
                elif render_type == "line":
                    # Shouldn't happen for non-Spring blocks
                    pass
        
        # Set equal aspect ratio
        max_range = np.array([
            max([pos[0] for pos in block_positions.values()]) - min([pos[0] for pos in block_positions.values()]),
            max([pos[1] for pos in block_positions.values()]) - min([pos[1] for pos in block_positions.values()]),
            max([pos[2] for pos in block_positions.values()]) - min([pos[2] for pos in block_positions.values()])
        ]).max() / 2.0
        
        mid_x = (max([pos[0] for pos in block_positions.values()]) + min([pos[0] for pos in block_positions.values()])) / 2.0
        mid_y = (max([pos[1] for pos in block_positions.values()]) + min([pos[1] for pos in block_positions.values()])) / 2.0
        mid_z = (max([pos[2] for pos in block_positions.values()]) + min([pos[2] for pos in block_positions.values()])) / 2.0
        
        ax.set_xlim(mid_x - max_range, mid_x + max_range)
        ax.set_ylim(mid_y - max_range, mid_y + max_range)
        ax.set_zlim(mid_z - max_range, mid_z + max_range)
        
        # Add legend
        # Create legend entries for block types
        legend_elements = []
        for block_type in sorted(set(self.BLOCK_COLORS.keys())):
            legend_elements.append(plt.Line2D([0], [0], marker='s', color='w', label=block_type,
                                              markerfacecolor=self.BLOCK_COLORS[block_type], markersize=8))
        
        ax.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1.2, 1.0), fontsize=8)
        
        # Improve layout
        plt.tight_layout()
        
        # Determine output path
        if output_path is None:
            output_path = os.path.join(self.visualizations_dir, f"{task}_{prompt_id:03d}_{machine_id:03d}.png")
            
        # Ensure directory exists
        output_dir = os.path.dirname(output_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir, exist_ok=True)
            
        # Save visualization
        try:
            plt.savefig(output_path, dpi=300, bbox_inches='tight', facecolor='white')
            plt.close(fig)
            self.logger.info(f"Machine visualization saved to: {output_path}")
        except Exception as e:
            self.logger.error(f"Failed to save visualization to {output_path}: {str(e)}")
            plt.close(fig)
            raise

```