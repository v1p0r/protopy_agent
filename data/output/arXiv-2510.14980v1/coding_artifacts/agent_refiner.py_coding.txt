```python
# agent/refiner.py
import json
import re
from typing import List, Dict, Any, Optional
from utils.config import Config
from utils.logger import Logger
from representation.construction_tree import ConstructionTree
from agent.querier import ActiveEnvQuerier


class Refiner:
    """
    Self-critic agent that generates multiple revised machine designs based on
    environmental feedback. Implements the 'refiner' component of the iterative
    editing workflow described in the paper.
    
    Given an initial design and simulation feedback, generates ≥3 candidate revisions
    by interpreting failure patterns and proposing targeted structural modifications.
    Uses LLM sampling with controlled diversity to explore alternative designs.
    """

    def __init__(self, llm_model: str):
        """
        Initialize the Refiner with LLM model identifier.
        
        Args:
            llm_model (str): Identifier for the LLM to use (e.g., "qwen-2.5-14b-instruct")
        """
        self.llm_model = llm_model
        self.logger = Logger(__name__)
        self.config = Config("config.yaml")
        
        # Load configuration parameters
        self.temperature = self.config.get("agent.temperature", 0.7)
        self.top_p = self.config.get("agent.top_p", 0.95)
        self.candidates_per_round = self.config.get("agent.candidates_per_round", 5)
        self.catapult_height_threshold = self.config.get("simulation.catapult_height_threshold", 3.0)
        self.max_output_length = self.config.get("model.max_output_length", 1168)
        
        # Build default prompt template
        self.prompt_template = self._build_default_prompt_template()
        
        # Block registry for validation
        try:
            from env.block_registry import BlockRegistry
            self.block_registry = BlockRegistry()
            self.valid_block_types = set(self.block_registry._valid_block_names)
        except ImportError:
            self.block_registry = None
            self.valid_block_types = set()  # Will be populated later if needed
        
        # Define failure pattern mappings for feedback interpretation
        # Maps feedback signals to natural language instructions for LLM
        self.feedback_interpretations = {
            "boulder_max_height_low": (
                "The boulder reached only {height:.1f}m maximum height (needs >{threshold}m). "
                "Increase the energy transfer by making the lever arm longer, "
                "increasing the counterweight mass, or raising the pivot point."
            ),
            "boulder_max_distance_low": (
                "The boulder only traveled {distance:.1f}m maximum distance. "
                "Improve the launch trajectory by adjusting the release angle, "
                "reducing friction on the launch path, or increasing the spring tension."
            ),
            "block_broke": (
                "Block with ID {block_id} ({block_type}) broke during simulation. "
                "This indicates structural weakness. Add a Brace near this block, "
                "reduce the mass on adjacent blocks, or reinforce the attachment points."
            ),
            "spring_too_long": (
                "The Spring (block {block_id}) exceeded maximum length of {max_len}m. "
                "Shorten the spring, add anchor points to limit extension, or reduce load."
            ),
            "spring_too_short": (
                "The Spring (block {block_id}) was compressed below minimum length of {min_len}m. "
                "Lengthen the spring, reduce preload, or adjust attachment points."
            ),
            "container_too_low": (
                "The Container (block {block_id}) was positioned too low at {position}. "
                "Raise the container by adjusting the lever arm length or pivot height."
            ),
            "root_not_moving": (
                "The Starting Block moved only {distance:.1f}m. "
                "Improve traction by adding more wheels, adjusting wheel placement, "
                "or reducing mass asymmetry."
            )
        }

    def _build_default_prompt_template(self) -> str:
        """
        Build the default prompt template as specified in the logic analysis.
        Enforces strict output format and uses only the 27 allowed blocks.
        
        Returns:
            str: Formatted prompt template with placeholders
        """
        # This will be populated dynamically in _build_prompt
        return """You are a mechanical design expert. You are given a machine design that failed to meet its goal. Analyze the feedback and propose 3 revised designs.

Current design:
{construction_tree_json}

Feedback:
{feedback_text}

Constraints:
- Use only the 27 blocks from BesiegeField.
- Do not change block types unless necessary.
- Do not scale or rotate blocks post-attachment.
- Maintain the construction tree format: list of dicts with "type", "id", "parent", "face_id".
- For Spring blocks, use "parent_a" and "parent_b" if needed.

Output exactly 3 revised construction trees in JSON list format. Do not explain. Do not add comments.
"""

    def _build_prompt(self, design: ConstructionTree, feedback: Dict[str, Any]) -> str:
        """
        Build the complete prompt by substituting the design and feedback into the template.
        Translates numerical feedback into natural language instructions for the LLM.
        
        Args:
            design (ConstructionTree): The current draft machine to be revised
            feedback (Dict[str, Any]): Feedback from ActiveEnvQuerier
            
        Returns:
            str: Complete prompt string
        """
        # Convert design to JSON string for prompt
        construction_tree_json = json.dumps(design.to_json(), indent=2)
        
        # Build feedback text from minimal and selective feedback
        feedback_text = ""
        
        # Extract task from minimal feedback
        task = feedback.get("minimal", {}).get("task", "car")
        
        # Process minimal feedback
        minimal = feedback.get("minimal", {})
        
        if task == "catapult":
            boulder_height = minimal.get("boulder_max_height", 0.0)
            boulder_distance = minimal.get("boulder_max_distance", 0.0)
            
            if boulder_height <= self.catapult_height_threshold:
                feedback_text += self.feedback_interpretations["boulder_max_height_low"].format(
                    height=boulder_height, threshold=self.catapult_height_threshold
                ) + "\n"
                
            if boulder_distance < 5.0:  # Arbitrary threshold for "low"
                feedback_text += self.feedback_interpretations["boulder_max_distance_low"].format(
                    distance=boulder_distance
                ) + "\n"
                
        elif task == "car":
            max_distance = minimal.get("max_moving_distance", 0.0)
            if max_distance < 1.0:  # Arbitrary threshold for "not moving"
                feedback_text += self.feedback_interpretations["root_not_moving"].format(
                    distance=max_distance
                ) + "\n"
        
        # Process selective feedback
        selective = feedback.get("selective", [])
        for query in selective:
            block_id = query.get("block_id")
            block_type = "Unknown"
            # Try to find block type from design
            if hasattr(self, 'block_registry') and self.block_registry:
                try:
                    block_info = design.get_block_by_id(block_id)
                    block_type = block_info.get("type", "Unknown")
                except:
                    pass
            
            query_types = query.get("query_types", [])
            time_window = query.get("time_window", [0.0, 0.0])
            data = query.get("data", [])
            
            if "length" in query_types and block_type == "Spring":
                if len(data) > 0:
                    lengths = [d.get("length", 0.0) for d in data]
                    max_length = max(lengths)
                    min_length = min(lengths)
                    
                    if max_length > 2.0:  # Threshold from paper heuristic
                        feedback_text += self.feedback_interpretations["spring_too_long"].format(
                            block_id=block_id, max_len=2.0
                        ) + "\n"
                    elif min_length < 0.2:  # Threshold from paper heuristic
                        feedback_text += self.feedback_interpretations["spring_too_short"].format(
                            block_id=block_id, min_len=0.2
                        ) + "\n"
            
            if "position" in query_types and block_type == "Container" and len(data) > 0:
                positions = [d.get("position", [0,0,0]) for d in data]
                y_positions = [pos[1] for pos in positions]
                avg_y = sum(y_positions) / len(y_positions)
                if avg_y < 0.5:  # Threshold for "too low"
                    feedback_text += self.feedback_interpretations["container_too_low"].format(
                        block_id=block_id, position=f"[{positions[0][0]:.1f}, {avg_y:.1f}, {positions[0][2]:.1f}]"
                    ) + "\n"
            
            if "integrity" in query_types and len(data) > 0:
                # Check if any block broke
                for d in data:
                    if d.get("integrity", 1.0) < 1.0:
                        feedback_text += self.feedback_interpretations["block_broke"].format(
                            block_id=block_id, block_type=block_type
                        ) + "\n"
                        break
        
        # If no feedback text generated, use generic message
        if not feedback_text.strip():
            feedback_text = "The machine did not perform well. Improve the design to achieve better functionality."
        
        # Build final prompt
        prompt = self.prompt_template.format(
            construction_tree_json=construction_tree_json,
            feedback_text=feedback_text.strip()
        )
        
        # Truncate if too long
        if len(prompt) > self.max_output_length:
            prompt = prompt[:self.max_output_length]
            self.logger.warning(f"Refiner prompt truncated to {self.max_output_length} characters")
            
        return prompt

    def _extract_json_arrays(self, raw_output: str) -> List[List[Dict[str, Any]]]:
        """
        Extract multiple JSON arrays from raw LLM output.
        Attempts to find and parse multiple valid JSON lists.
        
        Args:
            raw_output (str): Raw text output from LLM
            
        Returns:
            List[List[Dict[str, Any]]]: List of parsed JSON arrays
        """
        results = []
        
        if not raw_output:
            return results
            
        # Remove markdown code blocks
        cleaned = re.sub(r'^\s*```json\s*', '', raw_output, flags=re.IGNORECASE)
        cleaned = re.sub(r'^\s*```.*?\s*', '', cleaned, flags=re.DOTALL)
        cleaned = re.sub(r'\s*```$', '', cleaned, flags=re.DOTALL)
        
        # Find all potential JSON arrays using regex
        # Match patterns like [ ... ], [[ ... ]], etc.
        json_pattern = r'\[\s*[\s\S]*?\s*\]'
        matches = re.findall(json_pattern, cleaned)
        
        for match in matches:
            try:
                parsed = json.loads(match)
                if isinstance(parsed, list):
                    results.append(parsed)
            except json.JSONDecodeError:
                continue
                
        # If no matches found, try direct parsing
        if not results:
            try:
                parsed = json.loads(cleaned)
                if isinstance(parsed, list):
                    results.append(parsed)
            except json.JSONDecodeError:
                pass
                
        return results

    def _validate_and_filter_candidates(self, candidates: List[List[Dict[str, Any]]]) -> List[ConstructionTree]:
        """
        Validate candidate designs and filter out invalid or duplicate ones.
        
        Args:
            candidates (List[List[Dict[str, Any]]]): List of raw JSON arrays
            
        Returns:
            List[ConstructionTree]: List of valid, unique ConstructionTree objects
        """
        valid_trees = []
        seen_structures = set()
        
        for i, candidate in enumerate(candidates):
            # Skip empty candidates
            if not isinstance(candidate, list) or len(candidate) == 0:
                self.logger.debug(f"Skipping empty candidate {i}")
                continue
                
            # Ensure root block is first and has id=0
            if candidate[0].get("type") != "Starting Block" or candidate[0].get("id") != 0:
                # Try to fix: prepend root block if missing
                if candidate[0].get("type") != "Starting Block":
                    root_block = {"type": "Starting Block", "id": 0, "parent": None, "face_id": None}
                    # Adjust all IDs to be sequential starting from 0
                    for j, block in enumerate(candidate):
                        block["id"] = j + 1
                        if "parent" in block and block["parent"] is not None:
                            block["parent"] += 1
                        if "parent_a" in block and block["parent_a"] is not None:
                            block["parent_a"] += 1
                        if "parent_b" in block and block["parent_b"] is not None:
                            block["parent_b"] += 1
                    candidate.insert(0, root_block)
                    self.logger.warning(f"Fixed missing Starting Block in candidate {i}")
                else:
                    # ID is not 0, adjust
                    candidate[0]["id"] = 0
                    self.logger.warning(f"Fixed ID of first block to 0 in candidate {i}")
            
            # Validate all blocks are in allowed list
            valid_candidate = True
            for j, block in enumerate(candidate):
                block_type = block.get("type")
                if block_type not in self.valid_block_types:
                    self.logger.error(f"Invalid block type '{block_type}' at index {j} in candidate {i}")
                    valid_candidate = False
                    break
                    
            if not valid_candidate:
                continue
                
            # Validate IDs are sequential integers starting from 0
            expected_ids = list(range(len(candidate)))
            actual_ids = [block.get("id") for block in candidate]
            if actual_ids != expected_ids:
                # Try to fix sequential IDs
                for j, block in enumerate(candidate):
                    block["id"] = j
                self.logger.warning(f"Fixed non-sequential block IDs in candidate {i}")
            
            # Create ConstructionTree and validate
            try:
                tree = ConstructionTree(candidate)
                is_valid, error_msg = tree.validate()
                if not is_valid:
                    self.logger.error(f"Construction tree validation failed for candidate {i}: {error_msg}")
                    continue
                    
                # Check for duplicates by serializing the tree structure
                # We'll use a simplified serialization: list of (type, parent, face_id) tuples
                # This ignores position and orientation since we're comparing structure
                structure_signature = []
                for block in candidate:
                    signature = (
                        block.get("type"),
                        block.get("parent"),
                        block.get("parent_a"),
                        block.get("parent_b"),
                        block.get("face_id"),
                        block.get("face_id_a"),
                        block.get("face_id_b")
                    )
                    structure_signature.append(signature)
                
                # Convert to hashable tuple
                structure_tuple = tuple(structure_signature)
                
                if structure_tuple in seen_structures:
                    self.logger.debug(f"Duplicate candidate detected (candidate {i})")
                    continue
                    
                seen_structures.add(structure_tuple)
                valid_trees.append(tree)
                
            except Exception as e:
                self.logger.error(f"Failed to create ConstructionTree for candidate {i}: {str(e)}")
                continue
                
        return valid_trees

    def _call_llm(self, prompt: str) -> str:
        """
        Simulate LLM call. In production, this would be replaced with actual API integration.
        Uses the configured parameters (temperature, top_p) for generation.
        
        Args:
            prompt (str): Complete prompt string
            
        Returns:
            str: Simulated LLM response
        """
        # This is a placeholder for the actual LLM API call
        # In a real implementation, this would make an API call to the LLM service
        # For example: response = llm_api(prompt, temperature=self.temperature, top_p=self.top_p, max_tokens=self.max_output_length)
        
        # For simulation purposes, return a deterministic response
        # In production, replace with actual LLM call
        return """[
  [
    {"type": "Starting Block", "id": 0, "parent": null, "face_id": null},
    {"type": "Ballast", "id": 1, "parent": 0, "face_id": 0},
    {"type": "Wooden Rod", "id": 2, "parent": 1, "face_id": 0},
    {"type": "Hinge", "id": 3, "parent": 2, "face_id": 0},
    {"type": "Rotating Block", "id": 4, "parent": 3, "face_id": 0},
    {"type": "Container", "id": 5, "parent": 2, "face_id": 4}
  ],
  [
    {"type": "Starting Block", "id": 0, "parent": null, "face_id": null},
    {"type": "Ballast", "id": 1, "parent": 0, "face_id": 0},
    {"type": "Wooden Rod", "id": 2, "parent": 1, "face_id": 0},
    {"type": "Hinge", "id": 3, "parent": 2, "face_id": 0},
    {"type": "Rotating Block", "id": 4, "parent": 3, "face_id": 0},
    {"type": "Container", "id": 5, "parent": 4, "face_id": 0}
  ],
  [
    {"type": "Starting Block", "id": 0, "parent": null, "face_id": null},
    {"type": "Ballast", "id": 1, "parent": 0, "face_id": 0},
    {"type": "Wooden Rod", "id": 2, "parent": 1, "face_id": 0},
    {"type": "Hinge", "id": 3, "parent": 2, "face_id": 0},
    {"type": "Rotating Block", "id": 4, "parent": 3, "face_id": 0},
    {"type": "Container", "id": 5, "parent": 1, "face_id": 4}
  ],
  [
    {"type": "Starting Block", "id": 0, "parent": null, "face_id": null},
    {"type": "Ballast", "id": 1, "parent": 0, "face_id": 0},
    {"type": "Wooden Rod", "id": 2, "parent": 1, "face_id": 0},
    {"type": "Hinge", "id": 3, "parent": 2, "face_id": 0},
    {"type": "Rotating Block", "id": 4, "parent": 3, "face_id": 0},
    {"type": "Container", "id": 5, "parent": 0, "face_id": 4}
  ],
  [
    {"type": "Starting Block", "id": 0, "parent": null, "face_id": null},
    {"type": "Ballast", "id": 1, "parent": 0, "face_id": 0},
    {"type": "Wooden Rod", "id": 2, "parent": 1, "face_id": 0},
    {"type": "Hinge", "id": 3, "parent": 2, "face_id": 0},
    {"type": "Rotating Block", "id": 4, "parent": 3, "face_id": 0},
    {"type": "Container", "id": 5, "parent": 2, "face_id": 4},
    {"type": "Brace", "id": 6, "parent": 5, "face_id": 0}
  ]
]"""

    def refine(self, design: ConstructionTree, feedback: Dict[str, Any]) -> List[ConstructionTree]:
        """
        Generate multiple revised machine designs based on the current design and feedback.
        
        Args:
            design (ConstructionTree): The current draft machine to be revised (must be valid)
            feedback (Dict[str, Any]): Feedback from ActiveEnvQuerier containing minimal and selective feedback
            
        Returns:
            List[ConstructionTree]: List of revised machine designs (≥3 candidates, but may be fewer if validation fails)
        """
        # Validate input design
        if not design.is_valid():
            self.logger.error("Refiner received invalid design")
            return []
            
        # Build prompt from design and feedback
        prompt = self._build_prompt(design, feedback)
        
        # Call LLM to generate responses
        raw_output = self._call_llm(prompt)
        
        # Extract JSON arrays from raw output
        candidate_jsons = self._extract_json_arrays(raw_output)
        
        # Validate and filter candidates
        valid_candidates = self._validate_and_filter_candidates(candidate_jsons)
        
        # Ensure we have at least 3 candidates if possible
        # If we have fewer than 3, try to generate more by reusing the original design with minor modifications
        if len(valid_candidates) < 3:
            # Try to generate additional candidates by copying the original and making small changes
            original_json = design.to_json()
            # Create variations by changing one attachment point
            for i in range(3 - len(valid_candidates)):
                if len(original_json) < 2:
                    break
                    
                # Make a copy
                new_json = [block.copy() for block in original_json]
                
                # Change one parent attachment (if possible)
                # Find a non-root block with a parent
                for j in range(1, len(new_json)):
                    block = new_json[j]
                    if "parent" in block and block["parent"] is not None:
                        # Try to change parent to a different existing block
                        # Skip root (id=0) and current parent
                        possible_parents = [k for k in range(len(new_json)) if k != 0 and k != block["parent"]]
                        if possible_parents:
                            # Pick a random parent (use modulo for deterministic behavior)
                            new_parent = possible_parents[j % len(possible_parents)]
                            block["parent"] = new_parent
                            # Change face_id to something different
                            if "face_id" in block:
                                block["face_id"] = (block["face_id"] + 1) % 6
                            break
                
                # Create new ConstructionTree
                try:
                    new_tree = ConstructionTree(new_json)
                    is_valid, error_msg = new_tree.validate()
                    if is_valid:
                        # Check for duplicate structure
                        structure_signature = []
                        for block in new_json:
                            signature = (
                                block.get("type"),
                                block.get("parent"),
                                block.get("parent_a"),
                                block.get("parent_b"),
                                block.get("face_id"),
                                block.get("face_id_a"),
                                block.get("face_id_b")
                            )
                            structure_signature.append(signature)
                        structure_tuple = tuple(structure_signature)
                        
                        # Check if this structure already exists
                        exists = False
                        for existing in valid_candidates:
                            existing_json = existing.to_json()
                            existing_signature = []
                            for b in existing_json:
                                sig = (
                                    b.get("type"),
                                    b.get("parent"),
                                    b.get("parent_a"),
                                    b.get("parent_b"),
                                    b.get("face_id"),
                                    b.get("face_id_a"),
                                    b.get("face_id_b")
                                )
                                existing_signature.append(sig)
                            existing_tuple = tuple(existing_signature)
                            
                            if structure_tuple == existing_tuple:
                                exists = True
                                break
                                
                        if not exists:
                            valid_candidates.append(new_tree)
                            if len(valid_candidates) >= 3:
                                break
                except Exception as e:
                    self.logger.warning(f"Failed to create variation candidate: {str(e)}")
                    continue
        
        self.logger.info(f"Refiner generated {len(valid_candidates)} valid revisions from {self.candidates_per_round} candidates")
        
        return valid_candidates

```