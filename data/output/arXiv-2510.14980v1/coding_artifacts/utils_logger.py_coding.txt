```python
# utils/logger.py
import logging
import os
from datetime import datetime
from utils.config import Config


class Logger:
    """
    Centralized logging utility for the BesiegeField system.
    Provides consistent, timestamped, file-and-console output with configuration-driven behavior.
    Designed for thread and process safety in multi-agent, multi-simulation environments.
    """

    def __init__(self, name: str, log_file: str = None, level: str = "INFO"):
        """
        Initialize the Logger with a module name and configuration from system defaults.
        
        Args:
            name (str): The name of the calling module (typically __name__)
            log_file (str, optional): Path to the log file. If None, uses default from config.
            level (str, optional): Logging level (DEBUG, INFO, WARNING, ERROR). If None, uses default from config.
            
        Raises:
            ValueError: If log_file or level are invalid
        """
        # Validate inputs
        if not isinstance(name, str) or not name:
            raise ValueError("Logger name must be a non-empty string")
            
        # Set default values from config if not provided
        if log_file is None:
            try:
                config = Config("config.yaml")
                log_file = config.get("logging.log_file", "logs/experiment.log")
            except Exception:
                log_file = "logs/experiment.log"
                
        if level is None:
            try:
                config = Config("config.yaml")
                level = config.get("logging.level", "INFO")
            except Exception:
                level = "INFO"
                
        # Validate level
        level_map = {
            "DEBUG": logging.DEBUG,
            "INFO": logging.INFO,
            "WARNING": logging.WARNING,
            "ERROR": logging.ERROR
        }
        
        if level not in level_map:
            raise ValueError(f"Invalid log level: {level}. Must be one of {list(level_map.keys())}")
            
        self.level = level_map[level]
        self.name = name
        self.log_file = log_file
        
        # Create logger instance
        self.logger = logging.getLogger(name)
        self.logger.setLevel(self.level)
        
        # Clear any existing handlers to prevent duplication
        self.logger.handlers.clear()
        
        # Ensure log directory exists
        log_dir = os.path.dirname(log_file)
        if log_dir and not os.path.exists(log_dir):
            try:
                os.makedirs(log_dir, exist_ok=True)
            except Exception as e:
                # If directory creation fails, use current directory as fallback
                self.log_file = f"logs/experiment.log"
                log_dir = "logs"
                if not os.path.exists(log_dir):
                    os.makedirs(log_dir, exist_ok=True)
        
        # Create formatters
        formatter = logging.Formatter(
            '[%(asctime)sZ] [%(levelname)s] [%(name)s]: %(message)s',
            datefmt='%Y-%m-%dT%H:%M:%S.%f'
        )
        
        # File handler - always writes to file
        file_handler = logging.FileHandler(self.log_file, mode='a', encoding='utf-8')
        file_handler.setLevel(self.level)
        file_handler.setFormatter(formatter)
        self.logger.addHandler(file_handler)
        
        # Stream handler - writes to console (stdout/stderr)
        stream_handler = logging.StreamHandler()
        stream_handler.setLevel(self.level)
        stream_handler.setFormatter(formatter)
        
        # Redirect ERROR and CRITICAL to stderr, others to stdout
        if self.level <= logging.ERROR:
            stream_handler.stream = sys.stderr
        else:
            stream_handler.stream = sys.stdout
            
        self.logger.addHandler(stream_handler)
        
        # Prevent propagation to root logger (avoids duplicate logs)
        self.logger.propagate = False

    def info(self, msg: str) -> None:
        """
        Log an info message.
        
        Args:
            msg (str): The message to log
        """
        try:
            self.logger.info(msg)
        except Exception:
            # Fail silently if logging fails
            pass

    def error(self, msg: str) -> None:
        """
        Log an error message.
        
        Args:
            msg (str): The message to log
        """
        try:
            self.logger.error(msg)
        except Exception:
            # Fail silently if logging fails
            pass

    def warning(self, msg: str) -> None:
        """
        Log a warning message.
        
        Args:
            msg (str): The message to log
        """
        try:
            self.logger.warning(msg)
        except Exception:
            # Fail silently if logging fails
            pass

    def debug(self, msg: str) -> None:
        """
        Log a debug message (only if level is DEBUG).
        
        Args:
            msg (str): The message to log
        """
        try:
            self.logger.debug(msg)
        except Exception:
            # Fail silently if logging fails
            pass

    def exception(self, msg: str) -> None:
        """
        Log an error message with exception traceback.
        
        Args:
            msg (str): The message to log
        """
        try:
            self.logger.exception(msg)
        except Exception:
            # Fail silently if logging fails
            pass
```