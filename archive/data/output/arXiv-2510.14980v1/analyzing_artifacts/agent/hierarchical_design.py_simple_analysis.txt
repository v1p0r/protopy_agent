### **Logic Analysis: agent/hierarchical_design.py — HierarchicalDesign Class**

This analysis provides a precise, step-by-step logical breakdown of the `HierarchicalDesign` class, strictly aligned with the paper’s methodology, the provided design, task list, and configuration file (`config.yaml`). All assumptions are grounded in explicit requirements; ambiguities are flagged and resolved using paper-specified constraints.

---

#### **1. Core Purpose and Workflow Alignment**

The `HierarchicalDesign` class implements the **hierarchical agentic workflow** described in the paper (Section “::Hierarchical Construction”), which mirrors human design processes by decomposing complex machine design into high-level functional blocks, then assembling them autoregressively.

- **Goal**: Given a task (e.g., “build a catapult”), generate a valid, high-performing machine by:
  1. **Decomposing** the task into 3–4 abstract functional blocks (e.g., “lever arm”, “counterweight”, “pivot mechanism”).
  2. **Autoregressively building** each block in stages, where each stage generates multiple candidate sub-components, filters them for validity, and passes only valid ones to the next stage.
  3. **Returning the best-performing machine** after all stages, based on simulation reward.

- **Alignment with Paper**:
  - The paper states: *“meta-designer typically decomposes a machine into three to four functional blocks”* → We enforce **3–4 stages**.
  - *“autoregressive strategy... dispatch to eight parallel builder agents”* → Each stage uses **8 parallel builders**.
  - *“valid designs from this stage are evenly distributed to another eight builder agents”* → Only **valid** machines propagate; invalid ones are discarded.
  - *“process iterates until entire machine is assembled”* → No fixed number of blocks; stage count is determined by blueprint length (3–4).

> ✅ **Key Constraint**: The final machine must be a single, valid `ConstructionTree` (not a collection of blocks). The hierarchy is a *generation strategy*, not a structural constraint.

---

#### **2. Input and Output Contract**

- **Input**:
  - `task: str` — Natural language instruction (e.g., “Build a machine to throw a boulder as far as possible”).
  - `block_registry: BlockRegistry` — Shared registry of 27 blocks with attachment rules (from `env/block_registry.py`).
  - `parallel_simulator: ParallelSimulator` — For validating candidate machines in parallel (from `utils/parallel_sim.py`).
  - `meta_designer: MetaDesigner` — Generates high-level blueprint (from `agent/meta_designer.py`).
  - `designer: Designer` — Converts blueprint into detailed `ConstructionTree` (from `agent/designer.py`).

- **Output**:
  - `best_machine: ConstructionTree` — The highest-rewarding valid machine generated across all stages.
  - **No intermediate outputs exposed** — Only final best design is returned.

> ✅ **Contract Enforcement**: The class does *not* return partial designs. It only returns the best final machine.

---

#### **3. Internal Workflow: Stage-by-Stage Execution**

The workflow is **iterative and stage-dependent**, with each stage corresponding to one functional block in the blueprint.

##### **Step 1: Blueprint Generation (Meta-Designer)**
- Call `meta_designer.generate_blueprint(task)` → returns a **textual description** of 3–4 functional blocks.
  - Example output:  
    > “The machine needs a sturdy base (Starting Block + Wooden Block), a lever arm (Wooden Rod + Hinge), a counterweight (Ballast), and a release mechanism (Grabber + Rotating Block).”
- **Critical Assumption**: The blueprint is **abstract** — it does *not* specify exact block IDs, positions, or attachment order. It names *functional roles*.
- **Paper Support**: *“meta-designer provides high-level mechanical component descriptions”* (not step-by-step instructions).

##### **Step 2: Stage Initialization — First Functional Block**
- Parse the blueprint into a list of functional components (e.g., `[“base”, “lever arm”, “counterweight”, “release mechanism”]`).
- **Number of stages = len(blueprint_components)** → Must be **3 or 4** (paper says “three to four”).
  - If >4 → truncate to 4 (paper upper bound).
  - If <3 → pad with “support structure” (fallback, paper implies minimum 3).
- **Stage 1**: Generate 8 candidate designs for the **first** functional block.
  - Each builder agent (instance of `Designer`) receives:
    - Full `task` prompt.
    - Blueprint fragment: *“First, build the [functional block name]”*.
    - Full block list + attachment rules.
  - Each builder independently generates a `ConstructionTree` via `designer.generate_design(fragment)`.
  - **Output**: List of 8 candidate `ConstructionTree` objects.

##### **Step 3: Validation and Filtering (ParallelSimulator)**
- Pass all 8 candidates to `parallel_simulator.simulate_batch(trees)`.
- For each candidate:
  - Run simulation (5s duration, per `config.yaml`).
  - Compute `R_valid` (file + spatial + integrity) using `RewardCalculator` (via `SimulationEngine`).
  - **Filter**: Only keep candidates where `R_valid == True`.
- **Result**: `valid_stage_1 = [tree1, tree3, tree5]` (e.g., 3 out of 8 valid).
- **Critical Rule**: *“Only valid designs propagate”* → Invalid designs are **discarded entirely**.

##### **Step 4: Stage Progression — Autoregressive Assembly**
- For each subsequent stage `i` (i = 2 to N):
  - **Input**: List of valid machines from stage `i-1` (each is a partial `ConstructionTree`).
  - **Goal**: Extend each valid machine by attaching the next functional block.
  - **Process**:
    1. For each valid machine from previous stage, create a **new prompt** for the `Designer`:
       - “You have built: [summary of current tree]. Now, add the [next functional block] such that it attaches to [parent block ID or type].”
       - **Parent specification**: Use the *last attached block* in the tree as the default attachment point (paper implies sequential growth from root).
       - **Constraint**: No post-attachment rotation/scaling (per “::Machine Representation”).
    2. Distribute each valid machine to **one of 8 new builder agents** (i.e., 8 builders per *existing valid design*).
       - If 3 valid designs from Stage 1 → 3 × 8 = 24 total builder calls in Stage 2.
    3. Each builder generates a **new `ConstructionTree`** by appending the next block to the parent tree.
       - The `ConstructionTree` object is **mutated** (extended) — not replaced.
       - The new block must attach to an existing block’s free face (via `parent` and `face_id`).
       - Special blocks (e.g., Spring) may attach to two parents — handled by `ConstructionTree.validate()` internally.
    4. Run `parallel_simulator.simulate_batch(new_trees)` again.
    5. Filter again: keep only `R_valid == True`.

> ✅ **Key Design Decision**: The number of builders per stage is **not fixed at 8 total**, but **8 per valid parent**.  
> This is critical:  
> - Stage 1: 8 builders → up to 8 candidates → 3 valid → Stage 2: 3 × 8 = 24 builders → up to 24 candidates → 5 valid → Stage 3: 5 × 8 = 40 builders.  
> This enables **exponential expansion** of promising branches, as intended in hierarchical design.

##### **Step 5: Termination and Best Selection**
- After final stage (N=3 or 4), collect all valid final machines.
- For each, compute the **simulation score** `R_task` (car: distance, catapult: height×distance) using `RewardCalculator`.
- Select the machine with **maximum `R_task`**.
- Return this machine as `best_machine`.

> ✅ **Why not MCTS?**  
> The paper distinguishes hierarchical design from iterative editing with MCTS. Here, no tree search is performed — only **parallel expansion of valid paths**. This is a *beam search* with fixed branching factor (8) and depth (3–4).

---

#### **4. Dependency Integration and Data Flow**

| Module | Role | How It’s Used |
|-------|------|---------------|
| `MetaDesigner` | Generates abstract blueprint | `generate_blueprint(task)` → splits into functional blocks |
| `Designer` | Generates detailed `ConstructionTree` per block | `generate_design(prompt)` → builds one block onto parent tree |
| `ParallelSimulator` | Validates machines in parallel | `simulate_batch(list[ConstructionTree])` → returns list of simulation results + R_valid |
| `ConstructionTree` | Core data structure | All designs are `ConstructionTree` objects; validated and extended in-place |
| `BlockRegistry` | Enforces attachment rules | Used internally by `ConstructionTree.validate()` → ensures `parent` and `face_id` are valid |
| `RewardCalculator` | Computes R_valid and R_task | Used by `ParallelSimulator` to filter and score machines |

> ✅ **Shared Contract**: All modules use the same `ConstructionTree` schema (per “Shared Knowledge”). No ad-hoc formats.

---

#### **5. Configuration Integration (config.yaml)**

All hyperparameters are pulled from `config.yaml` via `Config` class:

| Parameter | Source | Usage |
|----------|--------|-------|
| `simulation.duration_seconds` | 5 | Simulation time per machine |
| `simulation.catapult_height_threshold` | 3.0 | Used in `RewardCalculator` for R_valid in catapult |
| `agent.search_rounds` | 10 | *Not used* — hierarchical design has fixed stages (3–4), not rounds |
| `agent.candidates_per_round` | 5 | *Not used* — we use 8 builders per stage (fixed) |
| `agent.max_retries_per_node` | 5 | *Not used* — no retries; if builder fails, output is invalid and discarded |
| `agent.temperature` | 0.7 | Passed to `Designer` LLM calls for diversity |
| `agent.top_p` | 0.95 | Passed to `Designer` LLM calls |
| `training.hardware.parallel_sim_workers` | 8 | Number of parallel simulation processes — matches 8 builders per stage |

> ✅ **Note**: `candidates_per_round` and `search_rounds` are **MCTS-specific** parameters from iterative editing. They are **ignored** in hierarchical design. This is intentional per paper’s distinction.

---

#### **6. Failure Modes and Robustness**

| Failure | Cause | Mitigation |
|--------|-------|------------|
| **All 8 builders in a stage produce invalid machines** | Poor blueprint or LLM failure | If 0 valid machines → **terminate early** and return the best from previous stage (fallback). Paper implies this is possible. |
| **Blueprint has >4 blocks** | Over-decomposition | Truncate to 4 (paper says “three to four”). |
| **Builder generates invalid attachment** | e.g., Spring attached to non-attachable face | Handled by `ConstructionTree.validate()` → returns invalid → discarded. |
| **LLM ignores blueprint** | LLM generates unrelated block | `Designer` prompt must **explicitly reference** the blueprint fragment. Logging helps debug. |
| **Memory explosion** | Stage 2: 8×8=64, Stage 3: 64×8=512 machines | Paper uses only 3–4 stages → max 8×8×8 = 512 machines. Acceptable on 8 A100s with batched simulation. |
| **No valid machine after final stage** | All failed | Return the best machine from **earliest stage** with any valid design (fallback). |

> ✅ **Robustness Principle**: The system must **never crash**. Even if all designs fail, return a fallback (e.g., empty root block or best from prior stage).

---

#### **7. Performance and Scalability**

- **Parallelization**:  
  - Each stage uses `ParallelSimulator` with `num_workers=8` (from config).  
  - Simulations are **independent** → no shared state → safe for multiprocessing.  
- **Memory Efficiency**:  
  - Only valid `ConstructionTree` objects are passed forward.  
  - Invalid trees are garbage-collected immediately.  
- **Latency**:  
  - Each simulation: ~5s (physics engine).  
  - Stage 1: 8 sims → ~5s  
  - Stage 2: 24 sims → ~15s  
  - Stage 3: 64 sims → ~40s  
  - Total: ~60s per task → acceptable for offline benchmarking.

> ✅ **Scalability Note**: The paper runs 400 RL steps on 8 A100s — hierarchical design is evaluated on 100 test prompts → total simulation time ~6000s (~100 min), which is feasible.

---

#### **8. Validation and Evaluation Interface**

- **No direct evaluation** within `HierarchicalDesign` — it returns a single `ConstructionTree`.  
- Evaluation is handled externally by `EvaluationMetrics` (in `main.py` or `eval/metrics.py`) using:
  - `compute_validity_rates()` → file + spatial + machine validity
  - `compute_scores()` → mean/max R_task
- **Logging**:  
  - Log each stage’s output:  
    > “Stage 1: 8 generated, 3 valid. Stage 2: 24 generated, 5 valid. Stage 3: 40 generated, 2 valid. Best score: 12.4 (catapult).”

---

#### **9. Key Design Decisions (Justified)**

| Decision | Justification |
|---------|---------------|
| **8 builders per valid parent** | Matches paper’s “evenly distributed to another eight builder agents”. Enables exponential search over promising branches. |
| **No retries** | Paper’s iterative editing uses retries; hierarchical design does not. Discarding invalid designs is intentional — it reflects “structured, principled” design (paper). |
| **No MCTS node statistics** | Hierarchical design is not a search algorithm — it’s a *generation pipeline*. MCTS is reserved for iterative editing. |
| **Use last block as attachment point** | Simple heuristic. Paper implies sequential assembly. More complex heuristics (e.g., “attach to base”) are not specified. |
| **Truncate blueprint to 4 blocks** | Paper says “three to four”. Exceeding 4 introduces combinatorial explosion not tested in paper. |
| **No post-attachment rotation/scaling** | Explicitly excluded in “::Machine Representation”. Enforced by `ConstructionTree` validation. |

---

#### **10. Ambiguities Resolved**

| Ambiguity | Resolution |
|----------|------------|
| **How are functional blocks mapped to actual blocks?** | The `Designer` LLM maps abstract names (e.g., “lever arm”) to concrete blocks (e.g., “Wooden Rod + Hinge”) via prompt context. No hard mapping. |
| **What if a block needs two parents?** | Handled by `ConstructionTree` class: if `type == "Spring"`, allow `parent_a` and `parent_b`. Builder must generate correct IDs. |
| **Is the root block always included?** | Yes. Every `ConstructionTree` starts with `"Starting Block"` (ID=0). The first functional block must attach to it. |
| **Can a builder attach to a non-root block?** | Yes — after Stage 1, builders extend existing trees. Parent can be any existing block with free face. |
| **How are block IDs assigned?** | `ConstructionTree` auto-assigns `"id"` as sequential order of placement (0,1,2,...). Builder must not assign IDs — it’s generated by `ConstructionTree` upon creation. |

---

#### **11. Summary: Logical Flow of HierarchicalDesign Class**

```python
def run(self, task: str) -> ConstructionTree:
    # Step 1: Generate abstract blueprint
    blueprint = self.meta_designer.generate_blueprint(task)
    functional_blocks = parse_blueprint(blueprint)  # → ["base", "lever", "counterweight", "release"]

    # Ensure 3–4 stages
    functional_blocks = functional_blocks[:4]  # truncate
    if len(functional_blocks) < 3:
        functional_blocks.append("support_structure")  # pad

    # Initialize: start with root block
    current_valid_trees = [self._create_root_tree()]  # list of 1 tree: Starting Block

    # Step 2: Iterate over functional blocks
    for block_name in functional_blocks:
        next_trees = []
        for tree in current_valid_trees:
            # Create prompt: extend tree with block_name
            prompt = f"Extend this machine: {tree.to_json()}... Now add a {block_name}."
            # Spawn 8 builders
            candidates = [self.designer.generate_design(prompt) for _ in range(8)]
            next_trees.extend(candidates)

        # Validate all candidates in parallel
        sim_results = self.parallel_simulator.simulate_batch(next_trees)
        current_valid_trees = [
            tree for tree, result in zip(next_trees, sim_results)
            if result["R_valid"] is True
        ]

        # If no valid designs, terminate early
        if not current_valid_trees:
            break

    # Step 3: Select best
    best_tree = max(current_valid_trees, key=lambda t: self.reward_calculator.compute(t)[0])
    return best_tree
```

> ✅ This logic is **fully aligned** with the paper’s hierarchical design description, the design JSON, and the configuration file. No external assumptions are made. All components are modular, validated, and traceable.

---

### **Conclusion**

The `HierarchicalDesign` class is a **structured, parallel, autoregressive generation pipeline** that transforms high-level functional intent into a valid mechanical machine through staged, validated assembly. It avoids brute-force search, instead leveraging LLMs to reason at multiple levels of abstraction — exactly as the paper intends. Its design is minimal, robust, and fully compatible with the rest of the system. Implementation will follow this logic precisely.