```python
# agent/querier.py
import json
from typing import List, Dict, Any, Optional, Tuple
from utils.config import Config
from env.block_registry import BlockRegistry
from representation.construction_tree import ConstructionTree


class ActiveEnvQuerier:
    """
    Extracts environmental feedback from simulation logs and performs selective queries
    based on failure patterns to guide iterative refinement in the agentic workflow.
    """

    def __init__(self, simulator: 'BesiegeFieldSimulator'):
        """
        Initialize the ActiveEnvQuerier with a reference to the BesiegeFieldSimulator.
        
        Args:
            simulator (BesiegeFieldSimulator): Instance that provides state_log after simulation
        """
        self.simulator = simulator
        self.block_registry = BlockRegistry()
        self.config = Config("config.yaml")
        
        # Load configuration values
        self.duration_seconds = self.config.get("simulation.duration_seconds", 5.0)
        self.state_log_interval = self.config.get("simulation.state_log_interval", 0.2)
        self.catapult_height_threshold = self.config.get("simulation.catapult_height_threshold", 3.0)
        
        # Calculate number of timesteps
        self.num_timesteps = int(self.duration_seconds / self.state_log_interval)
        
        # Define heuristics thresholds
        self.boulder_min_move_threshold = 0.5  # meters
        self.spring_min_length_threshold = 0.2  # meters
        self.spring_max_length_threshold = 2.0  # meters
        
        # Initialize logger
        self.logger = self._get_logger()

    def _get_logger(self):
        """Helper to get logger instance."""
        try:
            from utils.logger import Logger
            return Logger(__name__)
        except ImportError:
            import logging
            return logging.getLogger(__name__)

    def get_minimal_feedback(self, task: str, state_log: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Extract minimal feedback as specified in the paper's ::Environment Feedback section.
        Always returns this feedback regardless of machine performance.
        
        Args:
            task (str): Task type, either "car" or "catapult"
            state_log (List[Dict[str, Any]]): Simulation state log from BesiegeFieldSimulator
            
        Returns:
            Dict[str, Any]: Minimal feedback dictionary with task-specific keys
        """
        if not isinstance(state_log, list) or len(state_log) == 0:
            self.logger.warning("Empty state_log provided to get_minimal_feedback")
            return {"task": task, "minimal_data": {}}
            
        # Validate state_log structure
        if not isinstance(state_log[0], dict) or "blocks" not in state_log[0]:
            self.logger.error("Invalid state_log format: missing 'blocks' key")
            return {"task": task, "minimal_data": {}}
            
        feedback = {"task": task}
        
        if task == "car":
            # Find root block (Starting Block) trajectory
            root_block_id = 0
            root_trajectory = []
            for timestep in state_log:
                blocks = timestep.get("blocks", [])
                for block in blocks:
                    if block.get("block_id") == root_block_id:
                        root_trajectory.append(block)
                        break
            
            if len(root_trajectory) == 0:
                self.logger.warning("No Starting Block found in state_log for car task")
                feedback.update({
                    "machine_orientation": [0.0, 0.0, 0.0, 1.0],
                    "max_moving_distance": 0.0,
                    "max_speed": 0.0,
                    "avg_speed_per_second": 0.0,
                    "position_per_0_2s": []
                })
                return feedback
                
            # Extract positions and velocities
            positions = [block.get("position", [0.0, 0.0, 0.0]) for block in root_trajectory]
            velocities = [block.get("velocity", [0.0, 0.0, 0.0]) for block in root_trajectory]
            
            # Calculate max moving distance (along x-axis, designated forward direction)
            initial_x = positions[0][0]
            final_x = positions[-1][0]
            max_moving_distance = max(0.0, final_x - initial_x)
            
            # Calculate max speed (magnitude of velocity vector)
            max_speed = 0.0
            for vel in velocities:
                speed = (vel[0]**2 + vel[1]**2 + vel[2]**2)**0.5
                max_speed = max(max_speed, speed)
                
            # Calculate average speed per second
            avg_speed_per_second = max_moving_distance / self.duration_seconds
            
            # Extract orientations (use last timestep)
            last_root = root_trajectory[-1]
            machine_orientation = last_root.get("orientation", [0.0, 0.0, 0.0, 1.0])
            
            # Extract positions per 0.2s (all timesteps)
            position_per_0_2s = [pos for pos in positions]
            
            feedback.update({
                "machine_orientation": machine_orientation,
                "max_moving_distance": max_moving_distance,
                "max_speed": max_speed,
                "avg_speed_per_second": avg_speed_per_second,
                "position_per_0_2s": position_per_0_2s
            })
            
        elif task == "catapult":
            # Find boulder trajectory
            boulder_trajectory = []
            for timestep in state_log:
                blocks = timestep.get("blocks", [])
                for block in blocks:
                    if block.get("type") == "Boulder":
                        boulder_trajectory.append(block)
                        break
            
            if len(boulder_trajectory) == 0:
                self.logger.warning("No Boulder found in state_log for catapult task")
                feedback.update({
                    "boulder_max_distance": 0.0,
                    "boulder_max_height": 0.0,
                    "boulder_position_per_0_2s": []
                })
                return feedback
                
            # Extract positions
            positions = [block.get("position", [0.0, 0.0, 0.0]) for block in boulder_trajectory]
            
            # Calculate max distance (along x-axis) and max height (y-axis)
            max_distance = max(pos[0] for pos in positions)
            max_height = max(pos[1] for pos in positions)
            
            # Extract positions per 0.2s
            boulder_position_per_0_2s = [pos for pos in positions]
            
            feedback.update({
                "boulder_max_distance": max_distance,
                "boulder_max_height": max_height,
                "boulder_position_per_0_2s": boulder_position_per_0_2s
            })
            
        else:
            self.logger.error(f"Unknown task type: {task}")
            feedback.update({"minimal_data": {}})
            
        return feedback

    def selective_query(self, design: ConstructionTree, state_log: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Perform heuristic-driven selective queries on simulation data to identify failure patterns.
        Returns a list of query results, each containing block-specific data during critical time windows.
        
        Args:
            design (ConstructionTree): Valid construction tree of the simulated machine
            state_log (List[Dict[str, Any]]): Simulation state log from BesiegeFieldSimulator
            
        Returns:
            List[Dict[str, Any]]: List of selective query results, each with:
                - "block_id": int
                - "query_types": List[str] (e.g., ["position", "velocity", "length"])
                - "time_window": [start_t, end_t] in seconds
                - "data": List of dicts with t and requested fields
        """
        if not isinstance(state_log, list) or len(state_log) == 0:
            return []
            
        queries = []
        
        # Map block_id to block type from construction tree
        block_id_to_type = {}
        for block in design.to_json():
            block_id = block.get("id")
            block_type = block.get("type")
            if block_id is not None:
                block_id_to_type[block_id] = block_type
                
        # Extract time values from state_log (timestep index * state_log_interval)
        time_values = [i * self.state_log_interval for i in range(len(state_log))]
        
        # Heuristic 1: Boulder doesn't move (too little distance and height)
        if "catapult" in self._get_task_from_state_log(state_log):
            boulder_trajectory = []
            for timestep in state_log:
                for block in timestep.get("blocks", []):
                    if block.get("type") == "Boulder":
                        boulder_trajectory.append(block)
                        break
                        
            if len(boulder_trajectory) > 0:
                max_distance = max(pos[0] for pos in [b.get("position", [0,0,0]) for b in boulder_trajectory])
                max_height = max(pos[1] for pos in [b.get("position", [0,0,0]) for b in boulder_trajectory])
                
                if max_distance < self.boulder_min_move_threshold and max_height < self.boulder_min_move_threshold:
                    # Query Container block if exists
                    container_id = None
                    for block_id, block_type in block_id_to_type.items():
                        if block_type == "Container":
                            container_id = block_id
                            break
                            
                    if container_id is not None:
                        # Extract container data for entire simulation
                        container_data = []
                        for i, timestep in enumerate(state_log):
                            t = time_values[i]
                            for block in timestep.get("blocks", []):
                                if block.get("block_id") == container_id:
                                    container_data.append({
                                        "t": t,
                                        "position": block.get("position", [0,0,0]),
                                        "velocity": block.get("velocity", [0,0,0]),
                                        "orientation": block.get("orientation", [0,0,0,1])
                                    })
                                    break
                                    
                        queries.append({
                            "block_id": container_id,
                            "query_types": ["position", "velocity", "orientation"],
                            "time_window": [0.0, self.duration_seconds],
                            "data": container_data
                        })
                        
        # Heuristic 2: Boulder launched but too low (height <= threshold)
        if "catapult" in self._get_task_from_state_log(state_log):
            boulder_trajectory = []
            for timestep in state_log:
                for block in timestep.get("blocks", []):
                    if block.get("type") == "Boulder":
                        boulder_trajectory.append(block)
                        break
                        
            if len(boulder_trajectory) > 0:
                max_height = max(pos[1] for pos in [b.get("position", [0,0,0]) for b in boulder_trajectory])
                
                if max_height <= self.catapult_height_threshold:
                    # Query Boulder, Rotating Block, and any Lever/Container blocks
                    target_blocks = []
                    
                    # Always query boulder
                    boulder_id = None
                    for block_id, block_type in block_id_to_type.items():
                        if block_type == "Boulder":
                            boulder_id = block_id
                            break
                    if boulder_id is not None:
                        target_blocks.append(boulder_id)
                        
                    # Query Rotating Block if exists
                    rotating_block_id = None
                    for block_id, block_type in block_id_to_type.items():
                        if block_type == "Rotating Block":
                            rotating_block_id = block_id
                            break
                    if rotating_block_id is not None:
                        target_blocks.append(rotating_block_id)
                        
                    # Query any hinge or lever-like blocks
                    lever_blocks = []
                    for block_id, block_type in block_id_to_type.items():
                        if block_type in ["Hinge", "Steering Hinge", "Steering Block", "Container"]:
                            lever_blocks.append(block_id)
                    target_blocks.extend(lever_blocks)
                    
                    # For each target block, extract data from last 1.0s (last 5 timesteps)
                    last_1s_start_idx = max(0, len(time_values) - 5)  # 5 timesteps * 0.2s = 1.0s
                    last_1s_end_idx = len(time_values)
                    
                    for block_id in target_blocks:
                        block_data = []
                        for i in range(last_1s_start_idx, last_1s_end_idx):
                            t = time_values[i]
                            for block in state_log[i].get("blocks", []):
                                if block.get("block_id") == block_id:
                                    block_data.append({
                                        "t": t,
                                        "position": block.get("position", [0,0,0]),
                                        "velocity": block.get("velocity", [0,0,0]),
                                        "orientation": block.get("orientation", [0,0,0,1])
                                    })
                                    break
                                    
                        if len(block_data) > 0:
                            queries.append({
                                "block_id": block_id,
                                "query_types": ["position", "velocity", "orientation"],
                                "time_window": [time_values[last_1s_start_idx], time_values[last_1s_end_idx-1]],
                                "data": block_data
                            })
                            
        # Heuristic 3: Block broke during simulation
        broken_blocks = []
        for timestep in state_log:
            for block in timestep.get("blocks", []):
                if block.get("integrity", 1.0) < 1.0:
                    block_id = block.get("block_id")
                    if block_id is not None and block_id not in broken_blocks:
                        broken_blocks.append(block_id)
                        
        if len(broken_blocks) > 0:
            # Find the first broken block (lowest ID) as the most indicative failure point
            first_broken_block_id = min(broken_blocks)
            
            # Find the last attached block: in construction tree, it's the block itself
            # We query the broken block as it's the weak point
            block_type = block_id_to_type.get(first_broken_block_id, "Unknown")
            
            # Extract data from when it broke to end of simulation
            start_idx = None
            for i, timestep in enumerate(state_log):
                for block in timestep.get("blocks", []):
                    if block.get("block_id") == first_broken_block_id and block.get("integrity", 1.0) < 1.0:
                        start_idx = i
                        break
                if start_idx is not None:
                    break
                    
            if start_idx is None:
                start_idx = 0
                
            # Extract data from start_idx to end
            block_data = []
            for i in range(start_idx, len(state_log)):
                t = time_values[i]
                for block in state_log[i].get("blocks", []):
                    if block.get("block_id") == first_broken_block_id:
                        query_data = {
                            "t": t,
                            "position": block.get("position", [0,0,0]),
                            "velocity": block.get("velocity", [0,0,0]),
                            "orientation": block.get("orientation", [0,0,0,1]),
                            "integrity": block.get("integrity", 1.0)
                        }
                        # Add length if it's a Spring
                        if block_type == "Spring":
                            query_data["length"] = block.get("length", 0.0)
                        block_data.append(query_data)
                        break
                        
            if len(block_data) > 0:
                query_types = ["position", "velocity", "orientation", "integrity"]
                if block_type == "Spring":
                    query_types.append("length")
                    
                queries.append({
                    "block_id": first_broken_block_id,
                    "query_types": query_types,
                    "time_window": [time_values[start_idx], time_values[-1]],
                    "data": block_data
                })
                
        # Heuristic 4: Spring collapsed or overextended
        spring_blocks = []
        for block_id, block_type in block_id_to_type.items():
            if block_type == "Spring":
                spring_blocks.append(block_id)
                
        for spring_id in spring_blocks:
            # Extract spring data across entire simulation
            spring_data = []
            for i, timestep in enumerate(state_log):
                t = time_values[i]
                for block in timestep.get("blocks", []):
                    if block.get("block_id") == spring_id:
                        length = block.get("length", 0.0)
                        spring_data.append({
                            "t": t,
                            "length": length,
                            "position": block.get("position", [0,0,0])
                        })
                        break
                        
            if len(spring_data) > 0:
                # Check if spring is too short or too long
                lengths = [d["length"] for d in spring_data]
                min_length = min(lengths)
                max_length = max(lengths)
                
                if min_length < self.spring_min_length_threshold or max_length > self.spring_max_length_threshold:
                    queries.append({
                        "block_id": spring_id,
                        "query_types": ["length", "position"],
                        "time_window": [0.0, self.duration_seconds],
                        "data": spring_data
                    })
                    
        return queries

    def _get_task_from_state_log(self, state_log: List[Dict[str, Any]]) -> str:
        """
        Infer task type from state_log by checking for presence of Boulder block.
        
        Args:
            state_log (List[Dict[str, Any]]): Simulation state log
            
        Returns:
            str: "catapult" if Boulder found, "car" otherwise
        """
        if not isinstance(state_log, list) or len(state_log) == 0:
            return "car"
            
        for timestep in state_log:
            for block in timestep.get("blocks", []):
                if block.get("type") == "Boulder":
                    return "catapult"
        return "car"

    def get_feedback(self, task: str, design: ConstructionTree, state_log: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Combine minimal feedback and selective queries into a complete feedback dictionary.
        This is the primary interface used by InspectorRefiner and Refiner agents.
        
        Args:
            task (str): Task type ("car" or "catapult")
            design (ConstructionTree): Valid construction tree of the simulated machine
            state_log (List[Dict[str, Any]]): Simulation state log from BesiegeFieldSimulator
            
        Returns:
            Dict[str, Any]: Complete feedback dictionary with structure:
            {
                "minimal": {...},  # minimal feedback
                "selective": [...],  # list of selective queries
                "simulation_status": {  # summary of simulation health
                    "intact": bool,  # all blocks integrity == 1.0
                    "boulder_launched": bool,  # boulder_max_height > 0.5 (catapult)
                    "root_moved": bool  # root_moving_distance > 0.1 (car)
                }
            }
        """
        if not isinstance(state_log, list) or len(state_log) == 0:
            self.logger.warning("Empty state_log provided to get_feedback")
            return {
                "minimal": {},
                "selective": [],
                "simulation_status": {
                    "intact": False,
                    "boulder_launched": False,
                    "root_moved": False
                }
            }
            
        # Get minimal feedback
        minimal_feedback = self.get_minimal_feedback(task, state_log)
        
        # Get selective queries
        selective_queries = self.selective_query(design, state_log)
        
        # Compute simulation status
        simulation_status = {
            "intact": True,
            "boulder_launched": False,
            "root_moved": False
        }
        
        # Check if all blocks remained intact
        for timestep in state_log:
            for block in timestep.get("blocks", []):
                if block.get("integrity", 1.0) < 1.0:
                    simulation_status["intact"] = False
                    break
            if not simulation_status["intact"]:
                break
                
        # Check if boulder was launched (height > 0.5m) for catapult
        if task == "catapult":
            for timestep in state_log:
                for block in timestep.get("blocks", []):
                    if block.get("type") == "Boulder":
                        max_height = max(pos[1] for pos in [b.get("position", [0,0,0]) for b in timestep.get("blocks", []) if b.get("type") == "Boulder"])
                        simulation_status["boulder_launched"] = max_height > 0.5
                        break
                if simulation_status["boulder_launched"]:
                    break
                    
        # Check if root moved (distance > 0.1m) for car
        if task == "car":
            root_trajectory = []
            for timestep in state_log:
                for block in timestep.get("blocks", []):
                    if block.get("block_id") == 0:  # Starting Block
                        root_trajectory.append(block)
                        break
            if len(root_trajectory) >= 2:
                initial_x = root_trajectory[0].get("position", [0,0,0])[0]
                final_x = root_trajectory[-1].get("position", [0,0,0])[0]
                simulation_status["root_moved"] = abs(final_x - initial_x) > 0.1
                
        # Return complete feedback
        return {
            "minimal": minimal_feedback,
            "selective": selective_queries,
            "simulation_status": simulation_status
        }
```